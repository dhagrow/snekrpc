{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"snekrpc \u00b6 snekrpc is a lightweight Python RPC toolkit focused on fast prototyping for microservices and distributed systems. It ships a small core, with pluggable transports and codecs. A client-side Python library and CLI are generated at runtime based on metadata from services. Features \u00b6 Simple service model with metadata and runtime introspection Bi-directional streaming Built-in transports: TCP, Unix domain sockets, and HTTP (not REST) Built-in codecs: JSON and MessagePack (based on msgspec ) Built-in services: health , file , and remote (service pivoting/forwarding) Runtime generated client API Runtime generated client CLI Pre-generated typed client API Requirements \u00b6 Python 3.11+. Installation \u00b6 $ pip install snekrpc For development: $ git clone https://github.com/dhagrow/snekrpc.git $ cd snekrpc $ uv sync Quick start \u00b6 Define a service and start a server \u00b6 import snekrpc class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value server = snekrpc . Server() server . add_service(EchoService()) server . serve() The server will bind to tcp://127.0.0.1:12321 , by default. The client API and CLI will also connect to this, by default. You can pass in a different address in the same URL format, where the scheme determines the transport to use (e.g. http://localhost:5000 ). Call with a client API \u00b6 import snekrpc client = snekrpc . Client() echo_svc = client . service( 'echo' ) print (echo_svc . echo( 'hello' )) Call with a client CLI \u00b6 List available services and call a command: $ snekrpc usage: snekrpc [ -h ] ... { echo } ... # snekrpc <service-name> <command-name> <command-argument> $ snekrpc echo echo hello hello Streaming \u00b6 If a command accepts or returns an iterable/generator, it is streamed over the transport. Note that streaming to the server is only supported in the first argument of a command. class FileService (snekrpc . Service, name = 'file' ): @snekrpc . command() def download ( self , path: str ) -> Iterable[ bytes ]: with open (path, 'rb' ) as fp: for chunk in iter ( lambda : fp . read( 8192 ), b '' ): yield chunk @snekrpc . command() def upload ( self , data: Iterable[ bytes ], path: str ) -> None : with open (path, 'wb' ) as fp: for chunk in data: fp . write(chunk) On the CLI, streaming arguments accept a file path or - for stdin. What about asyncio ? \u00b6 There is not currently any support provided for asyncio . This is primarily due to the fact that I don't personally use asyncio in either my personal or professional work. Where I need asynchronous IO, I first reach for gevent . However I have found fewer and fewer appropriate use-cases for it over the years. I'm not opposed to making changes that simplify the integration of snekrpc with a project that uses asyncio , and will consider any PR to that end. However, I'm not willing to take on the maintenance burden of a feature I don't need or use. Besides, I'd rather be working on the projects this library enables. AI disclosure \u00b6 I used AI to support some of the documentation for this project. I reviewed all of it and rewrote much of it. I have not yet used AI to write any of the code, though I do have branches I may experiment with. Contributing \u00b6 Issues and pull requests are welcome. Please include tests for behavioral changes and keep the public API backwards compatible where possible. I'd like to be able License \u00b6 MIT","title":"Home"},{"location":"#snekrpc","text":"snekrpc is a lightweight Python RPC toolkit focused on fast prototyping for microservices and distributed systems. It ships a small core, with pluggable transports and codecs. A client-side Python library and CLI are generated at runtime based on metadata from services.","title":"snekrpc"},{"location":"#features","text":"Simple service model with metadata and runtime introspection Bi-directional streaming Built-in transports: TCP, Unix domain sockets, and HTTP (not REST) Built-in codecs: JSON and MessagePack (based on msgspec ) Built-in services: health , file , and remote (service pivoting/forwarding) Runtime generated client API Runtime generated client CLI Pre-generated typed client API","title":"Features"},{"location":"#requirements","text":"Python 3.11+.","title":"Requirements"},{"location":"#installation","text":"$ pip install snekrpc For development: $ git clone https://github.com/dhagrow/snekrpc.git $ cd snekrpc $ uv sync","title":"Installation"},{"location":"#quick-start","text":"","title":"Quick start"},{"location":"#define-a-service-and-start-a-server","text":"import snekrpc class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value server = snekrpc . Server() server . add_service(EchoService()) server . serve() The server will bind to tcp://127.0.0.1:12321 , by default. The client API and CLI will also connect to this, by default. You can pass in a different address in the same URL format, where the scheme determines the transport to use (e.g. http://localhost:5000 ).","title":"Define a service and start a server"},{"location":"#call-with-a-client-api","text":"import snekrpc client = snekrpc . Client() echo_svc = client . service( 'echo' ) print (echo_svc . echo( 'hello' ))","title":"Call with a client API"},{"location":"#call-with-a-client-cli","text":"List available services and call a command: $ snekrpc usage: snekrpc [ -h ] ... { echo } ... # snekrpc <service-name> <command-name> <command-argument> $ snekrpc echo echo hello hello","title":"Call with a client CLI"},{"location":"#streaming","text":"If a command accepts or returns an iterable/generator, it is streamed over the transport. Note that streaming to the server is only supported in the first argument of a command. class FileService (snekrpc . Service, name = 'file' ): @snekrpc . command() def download ( self , path: str ) -> Iterable[ bytes ]: with open (path, 'rb' ) as fp: for chunk in iter ( lambda : fp . read( 8192 ), b '' ): yield chunk @snekrpc . command() def upload ( self , data: Iterable[ bytes ], path: str ) -> None : with open (path, 'wb' ) as fp: for chunk in data: fp . write(chunk) On the CLI, streaming arguments accept a file path or - for stdin.","title":"Streaming"},{"location":"#what-about-asyncio","text":"There is not currently any support provided for asyncio . This is primarily due to the fact that I don't personally use asyncio in either my personal or professional work. Where I need asynchronous IO, I first reach for gevent . However I have found fewer and fewer appropriate use-cases for it over the years. I'm not opposed to making changes that simplify the integration of snekrpc with a project that uses asyncio , and will consider any PR to that end. However, I'm not willing to take on the maintenance burden of a feature I don't need or use. Besides, I'd rather be working on the projects this library enables.","title":"What about asyncio?"},{"location":"#ai-disclosure","text":"I used AI to support some of the documentation for this project. I reviewed all of it and rewrote much of it. I have not yet used AI to write any of the code, though I do have branches I may experiment with.","title":"AI disclosure"},{"location":"#contributing","text":"Issues and pull requests are welcome. Please include tests for behavioral changes and keep the public API backwards compatible where possible. I'd like to be able","title":"Contributing"},{"location":"#license","text":"MIT","title":"License"},{"location":"api/","text":"API Reference \u00b6 Server \u00b6 Bases: Interface Source code in snekrpc/interface.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Server (Interface): def __init__ ( self , transport: str | Transport | None = None , codec: str | Any | None = None , version: str | None = None , remote_tracebacks: bool = False , ) -> None : super () . __init__ (transport, codec or DEFAULT_CODEC) self . _services: dict [ str , Service] = {} self . add_service(create_service( 'meta' , server = self ), name = '_meta' ) self . version = version self . remote_tracebacks = remote_tracebacks log . info( 'server version: %s ' , version or '-' ) def serve ( self ) -> None : try : self . transport . serve( self ) except Exception as exc: raise errors . TransportError(exc) from exc def handle ( self , con: Connection) -> None : protocol . Protocol( self , con) . handle() def stop ( self ) -> None : self . transport . stop() def join ( self , timeout: float | None = None ) -> None : self . transport . join(timeout) def add_service ( self , service: Service, name: str | None = None ) -> Server: \"\"\"Register a service with the server. You can register a service but keep it hidden from users by prefixing the name with an underscore. \"\"\" name = name or SERVICE_REGISTRY . get_name( type (service)) self . _services[name] = service log . debug( 'service added: %s ' , name) return self def remove_service ( self , name: str ) -> Server: del self . _services[name] return self def service ( self , name: str ) -> Service: return self . _services[name] def services ( self ) -> list [ tuple [ str , Service]]: return [(name, self . service(name)) for name in self . service_names()] def service_names ( self ) -> list [ str ]: return [name for name in self . _services if name and not name . startswith( '_' )] add_service(service, name =None ) \u00b6 Register a service with the server. You can register a service but keep it hidden from users by prefixing the name with an underscore. Source code in snekrpc/interface.py 136 137 138 139 140 141 142 143 144 145 def add_service ( self , service: Service, name: str | None = None ) -> Server: \"\"\"Register a service with the server. You can register a service but keep it hidden from users by prefixing the name with an underscore. \"\"\" name = name or SERVICE_REGISTRY . get_name( type (service)) self . _services[name] = service log . debug( 'service added: %s ' , name) return self Service base classes and helpers. ServiceProxy \u00b6 Client-side helper that exposes remote commands as callables. Source code in snekrpc/service/__init__.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class ServiceProxy : \"\"\"Client-side helper that exposes remote commands as callables.\"\"\" def __init__ ( self , name: str , client: Client, command_metadata: bool | Sequence[utils . function . SignatureSpec] = True , ): \"\"\"Cache remote service metadata and wrap remote commands. When `command_metadata` is `True`, metadata will be loaded from the remote metadata service. When `False`, no metadata will be loaded. Otherwise, a sequence of command metadata can be provided directly. \"\"\" self . _svc_name = name self . _client = client self . _commands: dict [ str , Callable[ ... , Any]] = {} self . _retry = utils . retry . Retry( client . retry_count, client . retry_interval, errors = [errors . TransportError], logger = log ) if command_metadata is True : meta = ServiceProxy( '_meta' , client, command_metadata =False ) svc = msgspec . convert(meta . service( self . _svc_name), ServiceSpec) self . _commands . update({c . name: wrap_call( self , c . name, c) for c in svc . commands}) elif command_metadata: self . _commands . update({c . name: wrap_call( self , c . name, c) for c in command_metadata}) def __getattr__ ( self , cmd_name: str ) -> Callable[ ... , Any]: \"\"\"Return a cached callable or lazily wrap the remote command.\"\"\" if self . _commands: try : return self . _commands[cmd_name] except KeyError as exc: raise AttributeError (cmd_name) from exc return wrap_call( self , cmd_name) def __dir__ ( self ) -> list [ str ]: \"\"\"Add remote command names to ``dir()`` results.\"\"\" return list ( self . _commands . keys()) + list ( super () . __dir__ ()) __dir__ () \u00b6 Add remote command names to dir() results. Source code in snekrpc/service/__init__.py 92 93 94 def __dir__ ( self ) -> list [ str ]: \"\"\"Add remote command names to ``dir()`` results.\"\"\" return list ( self . _commands . keys()) + list ( super () . __dir__ ()) __getattr__ (cmd_name) \u00b6 Return a cached callable or lazily wrap the remote command. Source code in snekrpc/service/__init__.py 83 84 85 86 87 88 89 90 def __getattr__ ( self , cmd_name: str ) -> Callable[ ... , Any]: \"\"\"Return a cached callable or lazily wrap the remote command.\"\"\" if self . _commands: try : return self . _commands[cmd_name] except KeyError as exc: raise AttributeError (cmd_name) from exc return wrap_call( self , cmd_name) __init__ (name, client, command_metadata =True ) \u00b6 Cache remote service metadata and wrap remote commands. When command_metadata is True , metadata will be loaded from the remote metadata service. When False , no metadata will be loaded. Otherwise, a sequence of command metadata can be provided directly. Source code in snekrpc/service/__init__.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , name: str , client: Client, command_metadata: bool | Sequence[utils . function . SignatureSpec] = True , ): \"\"\"Cache remote service metadata and wrap remote commands. When `command_metadata` is `True`, metadata will be loaded from the remote metadata service. When `False`, no metadata will be loaded. Otherwise, a sequence of command metadata can be provided directly. \"\"\" self . _svc_name = name self . _client = client self . _commands: dict [ str , Callable[ ... , Any]] = {} self . _retry = utils . retry . Retry( client . retry_count, client . retry_interval, errors = [errors . TransportError], logger = log ) if command_metadata is True : meta = ServiceProxy( '_meta' , client, command_metadata =False ) svc = msgspec . convert(meta . service( self . _svc_name), ServiceSpec) self . _commands . update({c . name: wrap_call( self , c . name, c) for c in svc . commands}) elif command_metadata: self . _commands . update({c . name: wrap_call( self , c . name, c) for c in command_metadata}) ServiceSpec \u00b6 Bases: Struct Description of a callable signature. Source code in snekrpc/service/__init__.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class ServiceSpec (msgspec . Struct, frozen =True ): \"\"\"Description of a callable signature.\"\"\" name: str doc: str | None commands: tuple [utils . function . SignatureSpec, ... ] @classmethod def from_service ( cls , svc: type [Service], service_name: str | None = None ) -> Self: \"\"\"Serialize a service definition for metadata responses.\"\"\" # commands have a `_meta` attribute commands = [] service_name = REGISTRY . get_name(svc) if service_name is None else service_name for name in dir (svc): if name . startswith( '_' ): continue attr = getattr (svc, name) if getattr (attr, '_meta' , None ) is not None : commands . append(utils . function . encode(attr, remove_self =True )) return cls (service_name, svc . __doc__, tuple (commands)) from_service(svc, service_name =None ) classmethod \u00b6 Serialize a service definition for metadata responses. Source code in snekrpc/service/__init__.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def from_service ( cls , svc: type [Service], service_name: str | None = None ) -> Self: \"\"\"Serialize a service definition for metadata responses.\"\"\" # commands have a `_meta` attribute commands = [] service_name = REGISTRY . get_name(svc) if service_name is None else service_name for name in dir (svc): if name . startswith( '_' ): continue attr = getattr (svc, name) if getattr (attr, '_meta' , None ) is not None : commands . append(utils . function . encode(attr, remove_self =True )) return cls (service_name, svc . __doc__, tuple (commands)) StreamInitiator \u00b6 Generator shim that ensures the generator is started. Source code in snekrpc/service/__init__.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class StreamInitiator : \"\"\"Generator shim that ensures the generator is started.\"\"\" def __init__ ( self , gen: Iterator[Any]) -> None : \"\"\"Prime the generator while preserving the first item.\"\"\" try : gen = itertools . chain([ next (gen)], gen) except StopIteration : pass self . _gen = gen def __iter__ ( self ) -> Iterator[Any]: \"\"\"Yield the cached first item followed by the original stream.\"\"\" yield from self . _gen __init__ (gen) \u00b6 Prime the generator while preserving the first item. Source code in snekrpc/service/__init__.py 100 101 102 103 104 105 106 def __init__ ( self , gen: Iterator[Any]) -> None : \"\"\"Prime the generator while preserving the first item.\"\"\" try : gen = itertools . chain([ next (gen)], gen) except StopIteration : pass self . _gen = gen __iter__ () \u00b6 Yield the cached first item followed by the original stream. Source code in snekrpc/service/__init__.py 108 109 110 def __iter__ ( self ) -> Iterator[Any]: \"\"\"Yield the cached first item followed by the original stream.\"\"\" yield from self . _gen wrap_call(proxy, cmd_name, cmd_spec =None ) \u00b6 Wrap a remote call in retry logic, handling stream outputs. Source code in snekrpc/service/__init__.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def wrap_call ( proxy: ServiceProxy, cmd_name: str , cmd_spec: utils . function . SignatureSpec | None = None ) -> Callable[ ... , Any]: \"\"\"Wrap a remote call in retry logic, handling stream outputs.\"\"\" def call ( * args: Any, ** kwargs: Any) -> Any: con = proxy . _client . connect() try : proto = protocol . Protocol(proxy . _client, con, {proxy . _svc_name: proxy . _commands}) res = proto . send_cmd(proxy . _svc_name, cmd_name, * args, ** kwargs) isgen = inspect . isgenerator(res) yield isgen if isgen: for r in res: yield r else : yield res except errors . TransportError: proxy . _client . close() raise def call_value ( * args: Any, ** kwargs: Any) -> Any: gen = call( * args, ** kwargs) isgen = next (gen) if isgen: raise errors . ParameterError( 'did not expect a stream' ) return next (gen) def call_stream ( * args: Any, ** kwargs: Any) -> Any: gen = call( * args, ** kwargs) isgen = next (gen) if not isgen: raise errors . ParameterError( 'expected a stream' ) return iter (StreamInitiator(gen)) if cmd_spec and cmd_spec . is_generator: def retry_wrap_gen ( * args: Any, ** kwargs: Any) -> Any: yield from proxy . _retry . call_gen(call_stream, * args, ** kwargs) callback = retry_wrap_gen else : def retry_wrap ( * args: Any, ** kwargs: Any) -> Any: return proxy . _retry . call(call_value, * args, ** kwargs) callback = retry_wrap if not cmd_spec: return callback return utils . function . decode(cmd_spec, callback) Base transport abstractions. Connection \u00b6 Wrap an underlying socket-like object and handle message encoding. Source code in snekrpc/transport/__init__.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class Connection : \"\"\"Wrap an underlying socket-like object and handle message encoding.\"\"\" def __init__ ( self , interface: Interface, addr: str ) -> None : \"\"\"Bind the connection to an interface instance and address.\"\"\" self . _ifc = interface self . _addr = addr @property def url ( self ) -> str : \"\"\"Return a string representation of the connection endpoint.\"\"\" return self . _addr def send ( self , data: bytes ) -> None : \"\"\"Send raw bytes.\"\"\" raise NotImplementedError def recv ( self ) -> bytes : \"\"\"Receive raw bytes.\"\"\" raise NotImplementedError def close ( self ) -> None : \"\"\"Close the underlying socket/resource.\"\"\" pass def __enter__ ( self ) -> 'Connection' : \"\"\"Allow context-manager usage.\"\"\" return self def __exit__ ( self , exc_type: type [ Exception ], exc: Exception , tb: TracebackType) -> None : \"\"\"Close the connection when leaving a `with` block.\"\"\" self . close() url property \u00b6 Return a string representation of the connection endpoint. __enter__ () \u00b6 Allow context-manager usage. Source code in snekrpc/transport/__init__.py 79 80 81 def __enter__ ( self ) -> 'Connection' : \"\"\"Allow context-manager usage.\"\"\" return self __exit__ (exc_type, exc, tb) \u00b6 Close the connection when leaving a with block. Source code in snekrpc/transport/__init__.py 83 84 85 def __exit__ ( self , exc_type: type [ Exception ], exc: Exception , tb: TracebackType) -> None : \"\"\"Close the connection when leaving a `with` block.\"\"\" self . close() __init__ (interface, addr) \u00b6 Bind the connection to an interface instance and address. Source code in snekrpc/transport/__init__.py 57 58 59 60 def __init__ ( self , interface: Interface, addr: str ) -> None : \"\"\"Bind the connection to an interface instance and address.\"\"\" self . _ifc = interface self . _addr = addr close() \u00b6 Close the underlying socket/resource. Source code in snekrpc/transport/__init__.py 75 76 77 def close ( self ) -> None : \"\"\"Close the underlying socket/resource.\"\"\" pass recv() \u00b6 Receive raw bytes. Source code in snekrpc/transport/__init__.py 71 72 73 def recv ( self ) -> bytes : \"\"\"Receive raw bytes.\"\"\" raise NotImplementedError send(data) \u00b6 Send raw bytes. Source code in snekrpc/transport/__init__.py 67 68 69 def send ( self , data: bytes ) -> None : \"\"\"Send raw bytes.\"\"\" raise NotImplementedError Transport \u00b6 Bases: ABC Base transport class mirrored across clients and servers. Source code in snekrpc/transport/__init__.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Transport (abc . ABC): \"\"\"Base transport class mirrored across clients and servers.\"\"\" def __init_subclass__ ( cls , / , name: str | None = None ) -> None : REGISTRY . set( cls . __name__ if name is None else name, cls ) def __init__ ( self , url: str | utils . url . Url): \"\"\"Store the normalized URL for later use.\"\"\" self . _url = utils . url . Url(url) @property def url ( self ) -> utils . url . Url: \"\"\"Return the configured transport URL.\"\"\" return self . _url @abc . abstractmethod def connect ( self , client: Any) -> Connection: \"\"\"Connect to a remote endpoint and return a Connection.\"\"\" raise NotImplementedError @abc . abstractmethod def serve ( self , server: Any) -> None : \"\"\"Start serving RPC requests.\"\"\" raise NotImplementedError @abc . abstractmethod def stop ( self ) -> None : \"\"\"Stop serving and release resources.\"\"\" raise NotImplementedError @abc . abstractmethod def join ( self , timeout: float | None = None ) -> None : \"\"\"Block until the server threads exit.\"\"\" raise NotImplementedError url property \u00b6 Return the configured transport URL. __init__ (url) \u00b6 Store the normalized URL for later use. Source code in snekrpc/transport/__init__.py 24 25 26 def __init__ ( self , url: str | utils . url . Url): \"\"\"Store the normalized URL for later use.\"\"\" self . _url = utils . url . Url(url) connect(client) abstractmethod \u00b6 Connect to a remote endpoint and return a Connection. Source code in snekrpc/transport/__init__.py 33 34 35 36 @abc . abstractmethod def connect ( self , client: Any) -> Connection: \"\"\"Connect to a remote endpoint and return a Connection.\"\"\" raise NotImplementedError join(timeout =None ) abstractmethod \u00b6 Block until the server threads exit. Source code in snekrpc/transport/__init__.py 48 49 50 51 @abc . abstractmethod def join ( self , timeout: float | None = None ) -> None : \"\"\"Block until the server threads exit.\"\"\" raise NotImplementedError serve(server) abstractmethod \u00b6 Start serving RPC requests. Source code in snekrpc/transport/__init__.py 38 39 40 41 @abc . abstractmethod def serve ( self , server: Any) -> None : \"\"\"Start serving RPC requests.\"\"\" raise NotImplementedError stop() abstractmethod \u00b6 Stop serving and release resources. Source code in snekrpc/transport/__init__.py 43 44 45 46 @abc . abstractmethod def stop ( self ) -> None : \"\"\"Stop serving and release resources.\"\"\" raise NotImplementedError create(url, * args, ** kwargs) \u00b6 Create a Transport instance for url . Source code in snekrpc/transport/__init__.py 95 96 97 def create (url: str | utils . url . Url, * args: Any, ** kwargs: Any) -> Transport: \"\"\"Create a `Transport` instance for *url*.\"\"\" return REGISTRY . create(utils . url . Url(url) . scheme, url, * args, ** kwargs) Codec base classes and helpers. Codec \u00b6 Bases: ABC Base class for codecs that know how to encode/decode RPC payloads. Source code in snekrpc/codec/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Codec (abc . ABC): \"\"\"Base class for codecs that know how to encode/decode RPC payloads.\"\"\" def __init_subclass__ ( cls , / , name: str | None = None ) -> None : REGISTRY . set( cls . __name__ if name is None else name, cls ) @abc . abstractmethod def encode ( self , msg: Any) -> bytes : \"\"\"Serialize `msg` into bytes.\"\"\" raise NotImplementedError ( 'abstract' ) @abc . abstractmethod def decode ( self , data: bytes ) -> Any: \"\"\"Deserialize bytes into Python objects.\"\"\" raise NotImplementedError ( 'abstract' ) def _encode ( self , msg: Any) -> bytes : \"\"\"Wrapper that provides encoding error context. Used internally.\"\"\" try : return self . encode(msg) except Exception as exc: raise errors . EncodeError( f ' { exc } : msg= { utils . format . elide( repr (msg)) } ' ) from exc def _decode ( self , data: bytes ) -> Any: \"\"\"Wrapper that provides decoding error context. Used internally.\"\"\" try : return self . decode(data) except Exception as exc: raise errors . DecodeError( f ' { exc } : data= { utils . format . elide( repr (data)) !r} ' ) from exc decode(data) abstractmethod \u00b6 Deserialize bytes into Python objects. Source code in snekrpc/codec/__init__.py 23 24 25 26 @abc . abstractmethod def decode ( self , data: bytes ) -> Any: \"\"\"Deserialize bytes into Python objects.\"\"\" raise NotImplementedError ( 'abstract' ) encode(msg) abstractmethod \u00b6 Serialize msg into bytes. Source code in snekrpc/codec/__init__.py 18 19 20 21 @abc . abstractmethod def encode ( self , msg: Any) -> bytes : \"\"\"Serialize `msg` into bytes.\"\"\" raise NotImplementedError ( 'abstract' ) Formatter plugin infrastructure. Formatter \u00b6 Base class for converting RPC responses to user output. Source code in snekrpc/formatter/__init__.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Formatter : \"\"\"Base class for converting RPC responses to user output.\"\"\" def __init_subclass__ ( cls , / , name: str | None = None ) -> None : REGISTRY . set( cls . __name__ if name is None else name, cls ) def process ( self , res: Any) -> None : \"\"\"Automatically iterate through generators and print results.\"\"\" if inspect . isgenerator(res): for value in res: self . print(value) else : self . print(res) def print ( self , res: Any) -> None : \"\"\"Print a formatted representation of `res`.\"\"\" print ( self . format(res)) def format ( self , res: Any) -> Any: \"\"\"Return the raw value by default; subclasses can override.\"\"\" return res format (res) \u00b6 Return the raw value by default; subclasses can override. Source code in snekrpc/formatter/__init__.py 29 30 31 def format ( self , res: Any) -> Any: \"\"\"Return the raw value by default; subclasses can override.\"\"\" return res print (res) \u00b6 Print a formatted representation of res . Source code in snekrpc/formatter/__init__.py 25 26 27 def print ( self , res: Any) -> None : \"\"\"Print a formatted representation of `res`.\"\"\" print ( self . format(res)) process(res) \u00b6 Automatically iterate through generators and print results. Source code in snekrpc/formatter/__init__.py 17 18 19 20 21 22 23 def process ( self , res: Any) -> None : \"\"\"Automatically iterate through generators and print results.\"\"\" if inspect . isgenerator(res): for value in res: self . print(value) else : self . print(res) Command-line entry points for interacting with local and remote servers. Parser \u00b6 Builds CLI parsers for both client and server workflows. Source code in snekrpc/cli.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 class Parser : \"\"\"Builds CLI parsers for both client and server workflows.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the base parser and global argument definitions.\"\"\" # global args self . base_parser = argparse . ArgumentParser(add_help =False ) self . add_global_args( self . base_parser) def main ( self ) -> None : \"\"\"Processes command-line arguments and calls any selected command.\"\"\" # temp parser to grab connection arguments parser = argparse . ArgumentParser(add_help =False , parents = [ self . base_parser]) parser . add_argument( '-h' , '--help' , action = 'store_true' , help = 'show this help message and exit' ) parser . add_argument( 'rest' , nargs = argparse . REMAINDER, help = argparse . SUPPRESS) args, extra_args = parser . parse_known_args() logs . init(args . verbose) # import built-in modules registry . init() # import additional modules for imp in args . imports: utils . path . import_module(imp) if args . list: meta = cast( registry . Registry[Any], { 'codecs' : codec . REGISTRY, 'formatters' : formatter . REGISTRY, 'services' : service . REGISTRY, 'transports' : transport . REGISTRY, }[args . list], ) # select an output formatter fmt = None try : fmt = formatter . create(args . format) except Exception as e: if args . verbose: raise parser . error( str (e)) assert fmt is not None fmt . process(meta . names()) return # parser for transport and service args parser = argparse . ArgumentParser(parents = [ self . base_parser]) transport_cls = transport . get(args . url) if isinstance (transport_cls, Exception ): self . add_transport_exception(parser, args . url . scheme, transport_cls) else : self . add_transport_args(parser, transport_cls) # add service arguments used_aliases = set () for name in sorted (args . services): name, alias = parse_alias(name) service_cls = service . get(name) alias = alias or name if alias in used_aliases: raise ValueError ( f 'duplicate service alias: { alias } ' ) used_aliases . add(alias) self . add_service_args(parser, service_cls, alias) # collect transport and service args sub_args = parser . parse_args(extra_args) trn_args, svc_args = self . get_prefixed_args(sub_args) trn_name = args . url . scheme trn = transport . create(args . url, ** trn_args . get(trn_name, {})) # start client or server if args . server_mode: # help if args . help: parser . print_help() parser . exit() if args . version is True : parser . error( 'expected a version string' ) if args . rest: parser . error( 'unrecognized arguments: {} ' . format( ' ' . join(args . rest))) self . start_server(trn, args, svc_args) else : try : self . start_client(trn, parser, args) except Exception as e: err = ' {}\\n connection required for help on remote services' if args . help: parser . print_help() print (err . format(e), file = sys . stderr) parser . exit() if args . verbose: raise parser . error(err . format(e)) def start_client ( self , trn: transport . Transport, parser: argparse . ArgumentParser, args: Args ) -> None : \"\"\"Connect to the remote server and execute a command.\"\"\" client = interface . Client( trn, codec = args . codec, retry_count = args . retry_count, retry_interval = args . retry_interval, ) # get service metadata svcs: list [service . ServiceSpec] | None = None try : meta = client . service( '_meta' ) if args . version: # show server status and exit status = meta . status() self . print_status(status) parser . exit() svcs = msgspec . convert(meta . services(), list [service . ServiceSpec]) except errors . RemoteError as e: if not args . verbose and e . name == 'KeyError' : parser . error( 'metadata service not available' ) raise if svcs is None : # parser.error exits above, but keep type-checkers happy. raise AssertionError ( 'unreachable' ) # add services svc_subs = parser . add_subparsers(title = 'remote services' ) for svc in sorted (svcs, key =lambda s: s . name): svc_name = svc . name svc_desc = self . get_help(svc . doc) svc_parser = svc_subs . add_parser(svc_name, help = svc_desc, description = svc . doc) svc_parser . set_defaults(svc_name = svc_name) # add service commands cmd_subs = svc_parser . add_subparsers(title = 'commands' , dest = 'command' ) cmd_subs . required = True for cmd in svc . commands: cmd_name = cmd . name cmd_desc = self . get_help(cmd . doc) cmd_parser = cmd_subs . add_parser(cmd_name, help = cmd_desc, description = cmd . doc) self . add_command_args(cmd_parser, cmd) cmd_parser . set_defaults(cmd_name = cmd_name, cmd_meta = cmd) # help if args . help: parser . print_help() parser . exit() elif not args . rest: parser . print_usage() parser . exit() # select an output formatter fmt: Any | None = None try : fmt = formatter . create(args . format) except Exception as e: if args . verbose: raise parser . error( str (e)) assert fmt is not None # get the command arguments verbose = args . verbose args = parser . parse_args(args . rest) cmd_args, cmd_kwargs = self . get_command_args(args) # get the command function proxy = client . service(args . svc_name, metadata = [args . cmd_meta]) func = getattr (proxy, args . cmd_name) # call the command try : res = func( * cmd_args, ** cmd_kwargs) assert res is not None fmt . process(res) except Exception as e: if verbose: raise log . error( 'command error: %s ' , e) def start_server ( self , trn: transport . Transport, args: Args, svc_args: dict [ str , dict [ str , Any]], ) -> None : \"\"\"Start an RPC server with the configured services.\"\"\" # create server s = interface . Server( trn, codec = args . codec, version = args . version, remote_tracebacks = args . remote_tracebacks, ) # add services for name in args . services: name, alias = parse_alias(name) s_args = svc_args . get(name, {}) svc = service . create(name, ** s_args) s . add_service(svc, alias) s . serve() ## get arguments ## def get_prefixed_args ( self , args: Args) -> tuple [ dict [ str , Any], dict [ str , Any]]: \"\"\"Split parsed values into transport and service dictionaries.\"\"\" pfx_args: dict [ str , dict [ str , Any]] = {} for name, value in vars (args) . items(): try : prefix, cls_name, arg_name = name . split( '_' , 2 ) except ValueError : continue cls_args = pfx_args . setdefault(prefix, {}) cls_args . setdefault(cls_name, {})[arg_name] = value return pfx_args . get( 'transport' , {}), pfx_args . get( 'service' , {}) def get_command_args ( self , args: Args) -> tuple [ list [Any], dict [ str , Any]]: \"\"\"Processes the command-line arguments and returns the arguments to pass to the selected command.\"\"\" cmd: SignatureSpec = args . cmd_meta cmd_args: list [Any] = [] cmd_kwargs: dict [ str , Any] = {} for param in cmd . parameters: if param . hide: continue arg = getattr (args, param . name) if param . kind in {Param . POSITIONAL_ONLY, Param . POSITIONAL_OR_KEYWORD}: cmd_args . append(arg) elif param . kind == Param . VAR_POSITIONAL: cmd_args . extend(arg) elif param . kind == Param . VAR_KEYWORD: cmd_kwargs . update(arg or {}) elif param . kind == Param . KEYWORD_ONLY: cmd_kwargs[param . name] = arg else : raise AssertionError ( f 'unsupported argument kind: { param . kind } ' ) return cmd_args, cmd_kwargs ## add arguments ## def add_service_args ( self , parser: argparse . ArgumentParser, cls : Any, alias: str ) -> None : \"\"\"Expose ``cls.__init__`` parameters under the given service alias.\"\"\" svc_parser = parser . add_argument_group( ' {} service arguments' . format(alias)) # add a prefix to every param cmd = utils . function . encode( cls . __init__ , remove_self =True ) params = [] for param in cmd . parameters: param = msgspec . structs . replace( param, name = '_' . join([ 'service' , alias, param . name]), # force keyword-only params for clarity kind = param . kind if param . kind == Param . VAR_KEYWORD else Param . KEYWORD_ONLY, ) if not param . has_default: param = msgspec . structs . replace(param, default = argparse . SUPPRESS) params . append(param) self . add_command_args(svc_parser, cmd, single_flags =False ) def add_transport_args ( self , parser: argparse . ArgumentParser, cls : type [transport . Transport] ) -> None : \"\"\"Expose transport constructor parameters with a unique prefix.\"\"\" ignored = { 'url' , 'timeout' } trn_name = transport . REGISTRY . get_name( cls ) trn_parser = parser . add_argument_group( ' {} transport arguments' . format(trn_name), 'To see arguments for another transport, set the \"--url\" argument' , ) # add a prefix to every param cmd = utils . function . encode( cls . __init__ , remove_self =True ) params = [] for param in cmd . parameters: params . append( msgspec . structs . replace( param, name = '_' . join([ 'transport' , trn_name, param . name]), # force keyword-only params for clarity kind = param . kind if param . kind == Param . VAR_KEYWORD else Param . KEYWORD_ONLY, hide = param . name in ignored, ) ) cmd = msgspec . structs . replace(cmd, parameters = tuple (params)) self . add_command_args(trn_parser, cmd, single_flags =False ) def add_transport_exception ( self , parser: argparse . ArgumentParser, name: str , exc: Exception ) -> None : \"\"\"Display an error group when a transport fails to import.\"\"\" parser . add_argument_group( ' {} transport arguments' . format(name), 'failed to load transport: {} ' . format(exc), ) def add_command_args ( self , parser: Any, cmd: SignatureSpec, single_flags: bool = True ) -> None : \"\"\"Translate command metadata into argparse arguments.\"\"\" def is_option_arg (param: ParameterSpec) -> bool : return param . kind == Param . VAR_KEYWORD or param . has_default if single_flags: # keep track of used single char flags chars = set ( 'h' ) # include single char arguments chars . update( p . name for p in cmd . parameters if len (p . name) == 1 and not is_option_arg(p) ) else : chars = None for param in cmd . parameters: name = param . name kind = param . kind hint = param . annotation doc = param . doc if param . hide: continue kwargs: dict [ str , Any] = { 'metavar' : name} if param . has_default: kwargs[ 'default' ] = param . default if kind in {Param . KEYWORD_ONLY, Param . VAR_KEYWORD}: # **kwargs self . add_option_arg(parser, param, chars) elif param . has_default: # args with defaults self . add_option_arg(parser, param, chars) else : # positional args if kind == Param . VAR_POSITIONAL: # *args kwargs[ 'nargs' ] = '*' kwargs . update( { 'type' : self . get_converter(hint), 'help' : self . get_argument_help(doc, hint, param . default), } ) parser . add_argument(name, ** kwargs) def add_option_arg ( self , parser: Any, param: ParameterSpec, chars: set [ str ] | None = None ) -> None : \"\"\"Add an individual option flag, handling bool/kwargs special cases.\"\"\" name = param . name kind = param . kind hint = param . annotation doc = param . doc default = param . default # use dashes instead of underscores for param names flag_name = name . replace( '_' , '-' ) # check for possible short flags flags = [] added = False c = flag_name[ 0 ] C = c . upper() # check if the lower or uppercase char is unique if not chars: # don't add a short flag pass elif c not in chars: flags . append( '-' + c) chars . add(c) added = True elif C not in chars: flags . append( '-' + C) chars . add(C) added = True # add a long flag if no short flag was added # add a long flag if the name is more than 1 character if not added or len (flag_name) > 1 : flags . append( '--' + flag_name) if hint == 'bool' : # handle bool special case group = parser . add_mutually_exclusive_group() if not default: # in case default is None default = False help = self . get_argument_help(doc) # add a flag for the True value group . add_argument( * flags, action = 'store_true' , default = default, dest = name, help = help + ' (default)' if default is True else '' , ) # add a flag for the False value group . add_argument( '--no-' + flag_name, action = 'store_false' , dest = name, help = help + ' (default)' if default is False else '' , ) elif kind == Param . VAR_KEYWORD: parser . add_argument( * flags, action = 'append' , dest = name, type = self . get_converter( 'keyword' ), metavar = 'name=value' , default = default, help = self . get_argument_help(doc, None , default), ) else : parser . add_argument( * flags, dest = name, type = self . get_converter(hint), metavar = self . get_argument_hint(hint), default = default, help = self . get_argument_help(doc, None , default), ) def add_global_args ( self , parser: argparse . ArgumentParser) -> None : \"\"\"Adds an argument group to *parser* for global arguments.\"\"\" egroup = parser . add_mutually_exclusive_group() egroup . add_argument( '-C' , '--client' , action = 'store_false' , dest = 'server_mode' , help = 'start in client mode (default)' , default =False , ) egroup . add_argument( '-S' , '--server' , action = 'store_true' , dest = 'server_mode' , help = 'start in server mode' ) parser . add_argument( '-l' , '--list' , choices = [ 'codecs' , 'formatters' , 'services' , 'transports' ], help = 'list the modules available for the selected category' , ) parser . add_argument( '-v' , '--verbose' , action = 'count' , default = 0 , help = 'enable verbose output (-vv for more)' , ) parser . add_argument( '-V' , '--version' , nargs = '?' , const =True , help = 'show server version (client) or set server version (server)' , ) group = parser . add_argument_group( 'configuration arguments' ) group . add_argument( '-u' , '--url' , type = utils . url . Url, default = utils . DEFAULT_URL, metavar = 'TRANSPORT://HOST:PORT' , help = 'URL to connect or bind to (default: {} )' . format(utils . DEFAULT_URL), ) group . add_argument( '-i' , '--import' , action = 'append' , dest = 'imports' , metavar = 'IMPORT' , default = [], help = 'import an additional (codec/formatter/service/transport) module' , ) group . add_argument( '-c' , '--codec' , help = 'the codec format to use (default: {} on server)' . format(interface . DEFAULT_CODEC), ) group . add_argument( '-s' , '--service' , action = 'append' , dest = 'services' , metavar = 'SERVICE[:alias]' , default = [], help = 'register a service with the server (can be set multiple times)' , ) group = parser . add_argument_group( 'client arguments' ) group . add_argument( '-t' , '--timeout' , type = float , help = 'number of seconds to wait for a response (default: no timeout)' , ) group . add_argument( '-r' , '--retry-count' , type = int , help = 'number of retry attempts to make (-1 for unlimited, default: no retries)' , ) group . add_argument( '--retry-interval' , type = float , help = 'number of seconds between retry attempts (default: 1.0)' , ) group = parser . add_argument_group( 'server arguments' ) group . add_argument( '--remote-tracebacks' , action = 'store_true' , help = 'send tracebacks with errors' ) group = parser . add_argument_group( 'output arguments' ) format_default = { 'piped' : 'json' , 'redirected' : 'raw' , 'terminal' : 'pretty' , }[io_stat_mode()] group . add_argument( '-f' , '--format' , default = format_default, help = 'select a formatter by name or provide a custom Formatter ' \"subclass (default: 'pretty' on terminals, \" \"'json' when piped, and 'raw' when redirected)\" , ) ## parser help ## def get_help ( self , doc: str | None ) -> str : \"\"\"Return the first line of a documentation string.\"\"\" doc = doc or ' \\n ' return doc . splitlines()[ 0 ] def get_argument_help ( self , doc: str | None = None , hint: str | None = None , default: Any = None ) -> str : \"\"\"Build an argparse help string that includes hints and defaults.\"\"\" if is_stream_hint(hint): hint = \"path or '-' for stdin\" help = '< {} >' . format(hint) if hint else '' if doc: help = ' {} {} ' . format(doc, help) if default not in [Param . empty, argparse . SUPPRESS, None ]: help += ' (default: {} )' . format(default) return help def get_argument_hint ( self , hint: str | None ) -> str : \"\"\"Return a placeholder string usable as metavar text.\"\"\" if not hint: return '<str>' elif hint in COLLECTION_TYPES: return '<path or JSON>' else : return '< {} >' . format(hint) ## parser utils ## def get_converter ( self , hint: str | None ) -> Callable[[ str ], Any]: \"\"\"Returns a type converter keyed to a specific typehint.\"\"\" if hint == 'int' : def conv (value: str ) -> Any: return int (value) elif hint == 'float' : def conv (value: str ) -> Any: return float (value) elif hint == 'bytes' : def conv (value: str ) -> Any: return value . encode() elif is_stream_hint(hint): def conv (value: str ) -> Any: fp = cast(BinaryIO, argparse . FileType( 'rb' )(value)) return utils . path . iter_file(fp) elif hint == 'keyword' : def conv (value: str ) -> Any: return value . split( '=' , 1 ) elif hint == 'datetime' : def conv (value: str ) -> Any: try : return datetime . datetime . strptime(value, DATETIME_FORMAT) except ValueError : try : return datetime . datetime . strptime(value, DATE_FORMAT) except Exception : return datetime . datetime . combine( datetime . date . today(), datetime . datetime . strptime(value, TIME_FORMAT) . time(), ) elif hint == 'stream' : def conv (value: str ) -> Any: return (x for x in value) elif hint in COLLECTION_TYPES: def conv (value: str ) -> Any: try : with open (value) as f: return json . load(f) except Exception : return json . loads(value) else : def conv (value: str ) -> Any: return value # the converter name is used in error messages conv . __name__ = hint or 'str' return conv def print_status ( self , status: dict [ str , Any]) -> None : \"\"\"Prints the server version and status data.\"\"\" # TODO: abide by --format flag width = max ( len (k) for k in status) for k, v in sorted (status . items()): print ( '{:> {} }: {} ' . format(k, width, v or '-' )) __init__ () \u00b6 Initialize the base parser and global argument definitions. Source code in snekrpc/cli.py 39 40 41 42 43 def __init__ ( self ) -> None : \"\"\"Initialize the base parser and global argument definitions.\"\"\" # global args self . base_parser = argparse . ArgumentParser(add_help =False ) self . add_global_args( self . base_parser) add_command_args(parser, cmd, single_flags =True ) \u00b6 Translate command metadata into argparse arguments. Source code in snekrpc/cli.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def add_command_args ( self , parser: Any, cmd: SignatureSpec, single_flags: bool = True ) -> None : \"\"\"Translate command metadata into argparse arguments.\"\"\" def is_option_arg (param: ParameterSpec) -> bool : return param . kind == Param . VAR_KEYWORD or param . has_default if single_flags: # keep track of used single char flags chars = set ( 'h' ) # include single char arguments chars . update( p . name for p in cmd . parameters if len (p . name) == 1 and not is_option_arg(p) ) else : chars = None for param in cmd . parameters: name = param . name kind = param . kind hint = param . annotation doc = param . doc if param . hide: continue kwargs: dict [ str , Any] = { 'metavar' : name} if param . has_default: kwargs[ 'default' ] = param . default if kind in {Param . KEYWORD_ONLY, Param . VAR_KEYWORD}: # **kwargs self . add_option_arg(parser, param, chars) elif param . has_default: # args with defaults self . add_option_arg(parser, param, chars) else : # positional args if kind == Param . VAR_POSITIONAL: # *args kwargs[ 'nargs' ] = '*' kwargs . update( { 'type' : self . get_converter(hint), 'help' : self . get_argument_help(doc, hint, param . default), } ) parser . add_argument(name, ** kwargs) add_global_args(parser) \u00b6 Adds an argument group to parser for global arguments. Source code in snekrpc/cli.py 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 def add_global_args ( self , parser: argparse . ArgumentParser) -> None : \"\"\"Adds an argument group to *parser* for global arguments.\"\"\" egroup = parser . add_mutually_exclusive_group() egroup . add_argument( '-C' , '--client' , action = 'store_false' , dest = 'server_mode' , help = 'start in client mode (default)' , default =False , ) egroup . add_argument( '-S' , '--server' , action = 'store_true' , dest = 'server_mode' , help = 'start in server mode' ) parser . add_argument( '-l' , '--list' , choices = [ 'codecs' , 'formatters' , 'services' , 'transports' ], help = 'list the modules available for the selected category' , ) parser . add_argument( '-v' , '--verbose' , action = 'count' , default = 0 , help = 'enable verbose output (-vv for more)' , ) parser . add_argument( '-V' , '--version' , nargs = '?' , const =True , help = 'show server version (client) or set server version (server)' , ) group = parser . add_argument_group( 'configuration arguments' ) group . add_argument( '-u' , '--url' , type = utils . url . Url, default = utils . DEFAULT_URL, metavar = 'TRANSPORT://HOST:PORT' , help = 'URL to connect or bind to (default: {} )' . format(utils . DEFAULT_URL), ) group . add_argument( '-i' , '--import' , action = 'append' , dest = 'imports' , metavar = 'IMPORT' , default = [], help = 'import an additional (codec/formatter/service/transport) module' , ) group . add_argument( '-c' , '--codec' , help = 'the codec format to use (default: {} on server)' . format(interface . DEFAULT_CODEC), ) group . add_argument( '-s' , '--service' , action = 'append' , dest = 'services' , metavar = 'SERVICE[:alias]' , default = [], help = 'register a service with the server (can be set multiple times)' , ) group = parser . add_argument_group( 'client arguments' ) group . add_argument( '-t' , '--timeout' , type = float , help = 'number of seconds to wait for a response (default: no timeout)' , ) group . add_argument( '-r' , '--retry-count' , type = int , help = 'number of retry attempts to make (-1 for unlimited, default: no retries)' , ) group . add_argument( '--retry-interval' , type = float , help = 'number of seconds between retry attempts (default: 1.0)' , ) group = parser . add_argument_group( 'server arguments' ) group . add_argument( '--remote-tracebacks' , action = 'store_true' , help = 'send tracebacks with errors' ) group = parser . add_argument_group( 'output arguments' ) format_default = { 'piped' : 'json' , 'redirected' : 'raw' , 'terminal' : 'pretty' , }[io_stat_mode()] group . add_argument( '-f' , '--format' , default = format_default, help = 'select a formatter by name or provide a custom Formatter ' \"subclass (default: 'pretty' on terminals, \" \"'json' when piped, and 'raw' when redirected)\" , ) add_option_arg(parser, param, chars =None ) \u00b6 Add an individual option flag, handling bool/kwargs special cases. Source code in snekrpc/cli.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 def add_option_arg ( self , parser: Any, param: ParameterSpec, chars: set [ str ] | None = None ) -> None : \"\"\"Add an individual option flag, handling bool/kwargs special cases.\"\"\" name = param . name kind = param . kind hint = param . annotation doc = param . doc default = param . default # use dashes instead of underscores for param names flag_name = name . replace( '_' , '-' ) # check for possible short flags flags = [] added = False c = flag_name[ 0 ] C = c . upper() # check if the lower or uppercase char is unique if not chars: # don't add a short flag pass elif c not in chars: flags . append( '-' + c) chars . add(c) added = True elif C not in chars: flags . append( '-' + C) chars . add(C) added = True # add a long flag if no short flag was added # add a long flag if the name is more than 1 character if not added or len (flag_name) > 1 : flags . append( '--' + flag_name) if hint == 'bool' : # handle bool special case group = parser . add_mutually_exclusive_group() if not default: # in case default is None default = False help = self . get_argument_help(doc) # add a flag for the True value group . add_argument( * flags, action = 'store_true' , default = default, dest = name, help = help + ' (default)' if default is True else '' , ) # add a flag for the False value group . add_argument( '--no-' + flag_name, action = 'store_false' , dest = name, help = help + ' (default)' if default is False else '' , ) elif kind == Param . VAR_KEYWORD: parser . add_argument( * flags, action = 'append' , dest = name, type = self . get_converter( 'keyword' ), metavar = 'name=value' , default = default, help = self . get_argument_help(doc, None , default), ) else : parser . add_argument( * flags, dest = name, type = self . get_converter(hint), metavar = self . get_argument_hint(hint), default = default, help = self . get_argument_help(doc, None , default), ) add_service_args(parser, cls , alias) \u00b6 Expose cls.__init__ parameters under the given service alias. Source code in snekrpc/cli.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def add_service_args ( self , parser: argparse . ArgumentParser, cls : Any, alias: str ) -> None : \"\"\"Expose ``cls.__init__`` parameters under the given service alias.\"\"\" svc_parser = parser . add_argument_group( ' {} service arguments' . format(alias)) # add a prefix to every param cmd = utils . function . encode( cls . __init__ , remove_self =True ) params = [] for param in cmd . parameters: param = msgspec . structs . replace( param, name = '_' . join([ 'service' , alias, param . name]), # force keyword-only params for clarity kind = param . kind if param . kind == Param . VAR_KEYWORD else Param . KEYWORD_ONLY, ) if not param . has_default: param = msgspec . structs . replace(param, default = argparse . SUPPRESS) params . append(param) self . add_command_args(svc_parser, cmd, single_flags =False ) add_transport_args(parser, cls ) \u00b6 Expose transport constructor parameters with a unique prefix. Source code in snekrpc/cli.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def add_transport_args ( self , parser: argparse . ArgumentParser, cls : type [transport . Transport] ) -> None : \"\"\"Expose transport constructor parameters with a unique prefix.\"\"\" ignored = { 'url' , 'timeout' } trn_name = transport . REGISTRY . get_name( cls ) trn_parser = parser . add_argument_group( ' {} transport arguments' . format(trn_name), 'To see arguments for another transport, set the \"--url\" argument' , ) # add a prefix to every param cmd = utils . function . encode( cls . __init__ , remove_self =True ) params = [] for param in cmd . parameters: params . append( msgspec . structs . replace( param, name = '_' . join([ 'transport' , trn_name, param . name]), # force keyword-only params for clarity kind = param . kind if param . kind == Param . VAR_KEYWORD else Param . KEYWORD_ONLY, hide = param . name in ignored, ) ) cmd = msgspec . structs . replace(cmd, parameters = tuple (params)) self . add_command_args(trn_parser, cmd, single_flags =False ) add_transport_exception(parser, name, exc) \u00b6 Display an error group when a transport fails to import. Source code in snekrpc/cli.py 354 355 356 357 358 359 360 361 def add_transport_exception ( self , parser: argparse . ArgumentParser, name: str , exc: Exception ) -> None : \"\"\"Display an error group when a transport fails to import.\"\"\" parser . add_argument_group( ' {} transport arguments' . format(name), 'failed to load transport: {} ' . format(exc), ) get_argument_help(doc =None , hint =None , default =None ) \u00b6 Build an argparse help string that includes hints and defaults. Source code in snekrpc/cli.py 615 616 617 618 619 620 621 622 623 624 625 626 def get_argument_help ( self , doc: str | None = None , hint: str | None = None , default: Any = None ) -> str : \"\"\"Build an argparse help string that includes hints and defaults.\"\"\" if is_stream_hint(hint): hint = \"path or '-' for stdin\" help = '< {} >' . format(hint) if hint else '' if doc: help = ' {} {} ' . format(doc, help) if default not in [Param . empty, argparse . SUPPRESS, None ]: help += ' (default: {} )' . format(default) return help get_argument_hint(hint) \u00b6 Return a placeholder string usable as metavar text. Source code in snekrpc/cli.py 628 629 630 631 632 633 634 635 def get_argument_hint ( self , hint: str | None ) -> str : \"\"\"Return a placeholder string usable as metavar text.\"\"\" if not hint: return '<str>' elif hint in COLLECTION_TYPES: return '<path or JSON>' else : return '< {} >' . format(hint) get_command_args(args) \u00b6 Processes the command-line arguments and returns the arguments to pass to the selected command. Source code in snekrpc/cli.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def get_command_args ( self , args: Args) -> tuple [ list [Any], dict [ str , Any]]: \"\"\"Processes the command-line arguments and returns the arguments to pass to the selected command.\"\"\" cmd: SignatureSpec = args . cmd_meta cmd_args: list [Any] = [] cmd_kwargs: dict [ str , Any] = {} for param in cmd . parameters: if param . hide: continue arg = getattr (args, param . name) if param . kind in {Param . POSITIONAL_ONLY, Param . POSITIONAL_OR_KEYWORD}: cmd_args . append(arg) elif param . kind == Param . VAR_POSITIONAL: cmd_args . extend(arg) elif param . kind == Param . VAR_KEYWORD: cmd_kwargs . update(arg or {}) elif param . kind == Param . KEYWORD_ONLY: cmd_kwargs[param . name] = arg else : raise AssertionError ( f 'unsupported argument kind: { param . kind } ' ) return cmd_args, cmd_kwargs get_converter(hint) \u00b6 Returns a type converter keyed to a specific typehint. Source code in snekrpc/cli.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def get_converter ( self , hint: str | None ) -> Callable[[ str ], Any]: \"\"\"Returns a type converter keyed to a specific typehint.\"\"\" if hint == 'int' : def conv (value: str ) -> Any: return int (value) elif hint == 'float' : def conv (value: str ) -> Any: return float (value) elif hint == 'bytes' : def conv (value: str ) -> Any: return value . encode() elif is_stream_hint(hint): def conv (value: str ) -> Any: fp = cast(BinaryIO, argparse . FileType( 'rb' )(value)) return utils . path . iter_file(fp) elif hint == 'keyword' : def conv (value: str ) -> Any: return value . split( '=' , 1 ) elif hint == 'datetime' : def conv (value: str ) -> Any: try : return datetime . datetime . strptime(value, DATETIME_FORMAT) except ValueError : try : return datetime . datetime . strptime(value, DATE_FORMAT) except Exception : return datetime . datetime . combine( datetime . date . today(), datetime . datetime . strptime(value, TIME_FORMAT) . time(), ) elif hint == 'stream' : def conv (value: str ) -> Any: return (x for x in value) elif hint in COLLECTION_TYPES: def conv (value: str ) -> Any: try : with open (value) as f: return json . load(f) except Exception : return json . loads(value) else : def conv (value: str ) -> Any: return value # the converter name is used in error messages conv . __name__ = hint or 'str' return conv get_help(doc) \u00b6 Return the first line of a documentation string. Source code in snekrpc/cli.py 610 611 612 613 def get_help ( self , doc: str | None ) -> str : \"\"\"Return the first line of a documentation string.\"\"\" doc = doc or ' \\n ' return doc . splitlines()[ 0 ] get_prefixed_args(args) \u00b6 Split parsed values into transport and service dictionaries. Source code in snekrpc/cli.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def get_prefixed_args ( self , args: Args) -> tuple [ dict [ str , Any], dict [ str , Any]]: \"\"\"Split parsed values into transport and service dictionaries.\"\"\" pfx_args: dict [ str , dict [ str , Any]] = {} for name, value in vars (args) . items(): try : prefix, cls_name, arg_name = name . split( '_' , 2 ) except ValueError : continue cls_args = pfx_args . setdefault(prefix, {}) cls_args . setdefault(cls_name, {})[arg_name] = value return pfx_args . get( 'transport' , {}), pfx_args . get( 'service' , {}) main() \u00b6 Processes command-line arguments and calls any selected command. Source code in snekrpc/cli.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def main ( self ) -> None : \"\"\"Processes command-line arguments and calls any selected command.\"\"\" # temp parser to grab connection arguments parser = argparse . ArgumentParser(add_help =False , parents = [ self . base_parser]) parser . add_argument( '-h' , '--help' , action = 'store_true' , help = 'show this help message and exit' ) parser . add_argument( 'rest' , nargs = argparse . REMAINDER, help = argparse . SUPPRESS) args, extra_args = parser . parse_known_args() logs . init(args . verbose) # import built-in modules registry . init() # import additional modules for imp in args . imports: utils . path . import_module(imp) if args . list: meta = cast( registry . Registry[Any], { 'codecs' : codec . REGISTRY, 'formatters' : formatter . REGISTRY, 'services' : service . REGISTRY, 'transports' : transport . REGISTRY, }[args . list], ) # select an output formatter fmt = None try : fmt = formatter . create(args . format) except Exception as e: if args . verbose: raise parser . error( str (e)) assert fmt is not None fmt . process(meta . names()) return # parser for transport and service args parser = argparse . ArgumentParser(parents = [ self . base_parser]) transport_cls = transport . get(args . url) if isinstance (transport_cls, Exception ): self . add_transport_exception(parser, args . url . scheme, transport_cls) else : self . add_transport_args(parser, transport_cls) # add service arguments used_aliases = set () for name in sorted (args . services): name, alias = parse_alias(name) service_cls = service . get(name) alias = alias or name if alias in used_aliases: raise ValueError ( f 'duplicate service alias: { alias } ' ) used_aliases . add(alias) self . add_service_args(parser, service_cls, alias) # collect transport and service args sub_args = parser . parse_args(extra_args) trn_args, svc_args = self . get_prefixed_args(sub_args) trn_name = args . url . scheme trn = transport . create(args . url, ** trn_args . get(trn_name, {})) # start client or server if args . server_mode: # help if args . help: parser . print_help() parser . exit() if args . version is True : parser . error( 'expected a version string' ) if args . rest: parser . error( 'unrecognized arguments: {} ' . format( ' ' . join(args . rest))) self . start_server(trn, args, svc_args) else : try : self . start_client(trn, parser, args) except Exception as e: err = ' {}\\n connection required for help on remote services' if args . help: parser . print_help() print (err . format(e), file = sys . stderr) parser . exit() if args . verbose: raise parser . error(err . format(e)) print_status(status) \u00b6 Prints the server version and status data. Source code in snekrpc/cli.py 697 698 699 700 701 702 def print_status ( self , status: dict [ str , Any]) -> None : \"\"\"Prints the server version and status data.\"\"\" # TODO: abide by --format flag width = max ( len (k) for k in status) for k, v in sorted (status . items()): print ( '{:> {} }: {} ' . format(k, width, v or '-' )) start_client(trn, parser, args) \u00b6 Connect to the remote server and execute a command. Source code in snekrpc/cli.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def start_client ( self , trn: transport . Transport, parser: argparse . ArgumentParser, args: Args ) -> None : \"\"\"Connect to the remote server and execute a command.\"\"\" client = interface . Client( trn, codec = args . codec, retry_count = args . retry_count, retry_interval = args . retry_interval, ) # get service metadata svcs: list [service . ServiceSpec] | None = None try : meta = client . service( '_meta' ) if args . version: # show server status and exit status = meta . status() self . print_status(status) parser . exit() svcs = msgspec . convert(meta . services(), list [service . ServiceSpec]) except errors . RemoteError as e: if not args . verbose and e . name == 'KeyError' : parser . error( 'metadata service not available' ) raise if svcs is None : # parser.error exits above, but keep type-checkers happy. raise AssertionError ( 'unreachable' ) # add services svc_subs = parser . add_subparsers(title = 'remote services' ) for svc in sorted (svcs, key =lambda s: s . name): svc_name = svc . name svc_desc = self . get_help(svc . doc) svc_parser = svc_subs . add_parser(svc_name, help = svc_desc, description = svc . doc) svc_parser . set_defaults(svc_name = svc_name) # add service commands cmd_subs = svc_parser . add_subparsers(title = 'commands' , dest = 'command' ) cmd_subs . required = True for cmd in svc . commands: cmd_name = cmd . name cmd_desc = self . get_help(cmd . doc) cmd_parser = cmd_subs . add_parser(cmd_name, help = cmd_desc, description = cmd . doc) self . add_command_args(cmd_parser, cmd) cmd_parser . set_defaults(cmd_name = cmd_name, cmd_meta = cmd) # help if args . help: parser . print_help() parser . exit() elif not args . rest: parser . print_usage() parser . exit() # select an output formatter fmt: Any | None = None try : fmt = formatter . create(args . format) except Exception as e: if args . verbose: raise parser . error( str (e)) assert fmt is not None # get the command arguments verbose = args . verbose args = parser . parse_args(args . rest) cmd_args, cmd_kwargs = self . get_command_args(args) # get the command function proxy = client . service(args . svc_name, metadata = [args . cmd_meta]) func = getattr (proxy, args . cmd_name) # call the command try : res = func( * cmd_args, ** cmd_kwargs) assert res is not None fmt . process(res) except Exception as e: if verbose: raise log . error( 'command error: %s ' , e) start_server(trn, args, svc_args) \u00b6 Start an RPC server with the configured services. Source code in snekrpc/cli.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def start_server ( self , trn: transport . Transport, args: Args, svc_args: dict [ str , dict [ str , Any]], ) -> None : \"\"\"Start an RPC server with the configured services.\"\"\" # create server s = interface . Server( trn, codec = args . codec, version = args . version, remote_tracebacks = args . remote_tracebacks, ) # add services for name in args . services: name, alias = parse_alias(name) s_args = svc_args . get(name, {}) svc = service . create(name, ** s_args) s . add_service(svc, alias) s . serve() io_stat_mode() \u00b6 Return whether stdout is piped, redirected, or connected to a tty. Source code in snekrpc/cli.py 723 724 725 726 727 728 729 730 731 def io_stat_mode () -> str : \"\"\"Return whether stdout is piped, redirected, or connected to a tty.\"\"\" mode = os . fstat(sys . stdout . fileno()) . st_mode if stat . S_ISFIFO(mode): return 'piped' elif stat . S_ISREG(mode): return 'redirected' else : return 'terminal' main() \u00b6 Convenient entry-point. Source code in snekrpc/cli.py 31 32 33 def main () -> None : \"\"\"Convenient entry-point.\"\"\" Parser() . main() parse_alias(name) \u00b6 Split name into module and alias if : is present. Source code in snekrpc/cli.py 710 711 712 713 714 715 716 def parse_alias (name: str ) -> tuple [ str , str | None ]: \"\"\"Split ``name`` into ``module`` and ``alias`` if ``:`` is present.\"\"\" try : base, alias = name . split( ':' ) except ValueError : return name, None return base, alias","title":"API"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#snekrpc.interface.Server","text":"Bases: Interface Source code in snekrpc/interface.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Server (Interface): def __init__ ( self , transport: str | Transport | None = None , codec: str | Any | None = None , version: str | None = None , remote_tracebacks: bool = False , ) -> None : super () . __init__ (transport, codec or DEFAULT_CODEC) self . _services: dict [ str , Service] = {} self . add_service(create_service( 'meta' , server = self ), name = '_meta' ) self . version = version self . remote_tracebacks = remote_tracebacks log . info( 'server version: %s ' , version or '-' ) def serve ( self ) -> None : try : self . transport . serve( self ) except Exception as exc: raise errors . TransportError(exc) from exc def handle ( self , con: Connection) -> None : protocol . Protocol( self , con) . handle() def stop ( self ) -> None : self . transport . stop() def join ( self , timeout: float | None = None ) -> None : self . transport . join(timeout) def add_service ( self , service: Service, name: str | None = None ) -> Server: \"\"\"Register a service with the server. You can register a service but keep it hidden from users by prefixing the name with an underscore. \"\"\" name = name or SERVICE_REGISTRY . get_name( type (service)) self . _services[name] = service log . debug( 'service added: %s ' , name) return self def remove_service ( self , name: str ) -> Server: del self . _services[name] return self def service ( self , name: str ) -> Service: return self . _services[name] def services ( self ) -> list [ tuple [ str , Service]]: return [(name, self . service(name)) for name in self . service_names()] def service_names ( self ) -> list [ str ]: return [name for name in self . _services if name and not name . startswith( '_' )]","title":"Server"},{"location":"api/#snekrpc.interface.Server.add_service","text":"Register a service with the server. You can register a service but keep it hidden from users by prefixing the name with an underscore. Source code in snekrpc/interface.py 136 137 138 139 140 141 142 143 144 145 def add_service ( self , service: Service, name: str | None = None ) -> Server: \"\"\"Register a service with the server. You can register a service but keep it hidden from users by prefixing the name with an underscore. \"\"\" name = name or SERVICE_REGISTRY . get_name( type (service)) self . _services[name] = service log . debug( 'service added: %s ' , name) return self Service base classes and helpers.","title":"add_service"},{"location":"api/#snekrpc.service.ServiceProxy","text":"Client-side helper that exposes remote commands as callables. Source code in snekrpc/service/__init__.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class ServiceProxy : \"\"\"Client-side helper that exposes remote commands as callables.\"\"\" def __init__ ( self , name: str , client: Client, command_metadata: bool | Sequence[utils . function . SignatureSpec] = True , ): \"\"\"Cache remote service metadata and wrap remote commands. When `command_metadata` is `True`, metadata will be loaded from the remote metadata service. When `False`, no metadata will be loaded. Otherwise, a sequence of command metadata can be provided directly. \"\"\" self . _svc_name = name self . _client = client self . _commands: dict [ str , Callable[ ... , Any]] = {} self . _retry = utils . retry . Retry( client . retry_count, client . retry_interval, errors = [errors . TransportError], logger = log ) if command_metadata is True : meta = ServiceProxy( '_meta' , client, command_metadata =False ) svc = msgspec . convert(meta . service( self . _svc_name), ServiceSpec) self . _commands . update({c . name: wrap_call( self , c . name, c) for c in svc . commands}) elif command_metadata: self . _commands . update({c . name: wrap_call( self , c . name, c) for c in command_metadata}) def __getattr__ ( self , cmd_name: str ) -> Callable[ ... , Any]: \"\"\"Return a cached callable or lazily wrap the remote command.\"\"\" if self . _commands: try : return self . _commands[cmd_name] except KeyError as exc: raise AttributeError (cmd_name) from exc return wrap_call( self , cmd_name) def __dir__ ( self ) -> list [ str ]: \"\"\"Add remote command names to ``dir()`` results.\"\"\" return list ( self . _commands . keys()) + list ( super () . __dir__ ())","title":"ServiceProxy"},{"location":"api/#snekrpc.service.ServiceProxy.__dir__","text":"Add remote command names to dir() results. Source code in snekrpc/service/__init__.py 92 93 94 def __dir__ ( self ) -> list [ str ]: \"\"\"Add remote command names to ``dir()`` results.\"\"\" return list ( self . _commands . keys()) + list ( super () . __dir__ ())","title":"__dir__"},{"location":"api/#snekrpc.service.ServiceProxy.__getattr__","text":"Return a cached callable or lazily wrap the remote command. Source code in snekrpc/service/__init__.py 83 84 85 86 87 88 89 90 def __getattr__ ( self , cmd_name: str ) -> Callable[ ... , Any]: \"\"\"Return a cached callable or lazily wrap the remote command.\"\"\" if self . _commands: try : return self . _commands[cmd_name] except KeyError as exc: raise AttributeError (cmd_name) from exc return wrap_call( self , cmd_name)","title":"__getattr__"},{"location":"api/#snekrpc.service.ServiceProxy.__init__","text":"Cache remote service metadata and wrap remote commands. When command_metadata is True , metadata will be loaded from the remote metadata service. When False , no metadata will be loaded. Otherwise, a sequence of command metadata can be provided directly. Source code in snekrpc/service/__init__.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , name: str , client: Client, command_metadata: bool | Sequence[utils . function . SignatureSpec] = True , ): \"\"\"Cache remote service metadata and wrap remote commands. When `command_metadata` is `True`, metadata will be loaded from the remote metadata service. When `False`, no metadata will be loaded. Otherwise, a sequence of command metadata can be provided directly. \"\"\" self . _svc_name = name self . _client = client self . _commands: dict [ str , Callable[ ... , Any]] = {} self . _retry = utils . retry . Retry( client . retry_count, client . retry_interval, errors = [errors . TransportError], logger = log ) if command_metadata is True : meta = ServiceProxy( '_meta' , client, command_metadata =False ) svc = msgspec . convert(meta . service( self . _svc_name), ServiceSpec) self . _commands . update({c . name: wrap_call( self , c . name, c) for c in svc . commands}) elif command_metadata: self . _commands . update({c . name: wrap_call( self , c . name, c) for c in command_metadata})","title":"__init__"},{"location":"api/#snekrpc.service.ServiceSpec","text":"Bases: Struct Description of a callable signature. Source code in snekrpc/service/__init__.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class ServiceSpec (msgspec . Struct, frozen =True ): \"\"\"Description of a callable signature.\"\"\" name: str doc: str | None commands: tuple [utils . function . SignatureSpec, ... ] @classmethod def from_service ( cls , svc: type [Service], service_name: str | None = None ) -> Self: \"\"\"Serialize a service definition for metadata responses.\"\"\" # commands have a `_meta` attribute commands = [] service_name = REGISTRY . get_name(svc) if service_name is None else service_name for name in dir (svc): if name . startswith( '_' ): continue attr = getattr (svc, name) if getattr (attr, '_meta' , None ) is not None : commands . append(utils . function . encode(attr, remove_self =True )) return cls (service_name, svc . __doc__, tuple (commands))","title":"ServiceSpec"},{"location":"api/#snekrpc.service.ServiceSpec.from_service","text":"Serialize a service definition for metadata responses. Source code in snekrpc/service/__init__.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def from_service ( cls , svc: type [Service], service_name: str | None = None ) -> Self: \"\"\"Serialize a service definition for metadata responses.\"\"\" # commands have a `_meta` attribute commands = [] service_name = REGISTRY . get_name(svc) if service_name is None else service_name for name in dir (svc): if name . startswith( '_' ): continue attr = getattr (svc, name) if getattr (attr, '_meta' , None ) is not None : commands . append(utils . function . encode(attr, remove_self =True )) return cls (service_name, svc . __doc__, tuple (commands))","title":"from_service"},{"location":"api/#snekrpc.service.StreamInitiator","text":"Generator shim that ensures the generator is started. Source code in snekrpc/service/__init__.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class StreamInitiator : \"\"\"Generator shim that ensures the generator is started.\"\"\" def __init__ ( self , gen: Iterator[Any]) -> None : \"\"\"Prime the generator while preserving the first item.\"\"\" try : gen = itertools . chain([ next (gen)], gen) except StopIteration : pass self . _gen = gen def __iter__ ( self ) -> Iterator[Any]: \"\"\"Yield the cached first item followed by the original stream.\"\"\" yield from self . _gen","title":"StreamInitiator"},{"location":"api/#snekrpc.service.StreamInitiator.__init__","text":"Prime the generator while preserving the first item. Source code in snekrpc/service/__init__.py 100 101 102 103 104 105 106 def __init__ ( self , gen: Iterator[Any]) -> None : \"\"\"Prime the generator while preserving the first item.\"\"\" try : gen = itertools . chain([ next (gen)], gen) except StopIteration : pass self . _gen = gen","title":"__init__"},{"location":"api/#snekrpc.service.StreamInitiator.__iter__","text":"Yield the cached first item followed by the original stream. Source code in snekrpc/service/__init__.py 108 109 110 def __iter__ ( self ) -> Iterator[Any]: \"\"\"Yield the cached first item followed by the original stream.\"\"\" yield from self . _gen","title":"__iter__"},{"location":"api/#snekrpc.service.wrap_call","text":"Wrap a remote call in retry logic, handling stream outputs. Source code in snekrpc/service/__init__.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def wrap_call ( proxy: ServiceProxy, cmd_name: str , cmd_spec: utils . function . SignatureSpec | None = None ) -> Callable[ ... , Any]: \"\"\"Wrap a remote call in retry logic, handling stream outputs.\"\"\" def call ( * args: Any, ** kwargs: Any) -> Any: con = proxy . _client . connect() try : proto = protocol . Protocol(proxy . _client, con, {proxy . _svc_name: proxy . _commands}) res = proto . send_cmd(proxy . _svc_name, cmd_name, * args, ** kwargs) isgen = inspect . isgenerator(res) yield isgen if isgen: for r in res: yield r else : yield res except errors . TransportError: proxy . _client . close() raise def call_value ( * args: Any, ** kwargs: Any) -> Any: gen = call( * args, ** kwargs) isgen = next (gen) if isgen: raise errors . ParameterError( 'did not expect a stream' ) return next (gen) def call_stream ( * args: Any, ** kwargs: Any) -> Any: gen = call( * args, ** kwargs) isgen = next (gen) if not isgen: raise errors . ParameterError( 'expected a stream' ) return iter (StreamInitiator(gen)) if cmd_spec and cmd_spec . is_generator: def retry_wrap_gen ( * args: Any, ** kwargs: Any) -> Any: yield from proxy . _retry . call_gen(call_stream, * args, ** kwargs) callback = retry_wrap_gen else : def retry_wrap ( * args: Any, ** kwargs: Any) -> Any: return proxy . _retry . call(call_value, * args, ** kwargs) callback = retry_wrap if not cmd_spec: return callback return utils . function . decode(cmd_spec, callback) Base transport abstractions.","title":"wrap_call"},{"location":"api/#snekrpc.transport.Connection","text":"Wrap an underlying socket-like object and handle message encoding. Source code in snekrpc/transport/__init__.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class Connection : \"\"\"Wrap an underlying socket-like object and handle message encoding.\"\"\" def __init__ ( self , interface: Interface, addr: str ) -> None : \"\"\"Bind the connection to an interface instance and address.\"\"\" self . _ifc = interface self . _addr = addr @property def url ( self ) -> str : \"\"\"Return a string representation of the connection endpoint.\"\"\" return self . _addr def send ( self , data: bytes ) -> None : \"\"\"Send raw bytes.\"\"\" raise NotImplementedError def recv ( self ) -> bytes : \"\"\"Receive raw bytes.\"\"\" raise NotImplementedError def close ( self ) -> None : \"\"\"Close the underlying socket/resource.\"\"\" pass def __enter__ ( self ) -> 'Connection' : \"\"\"Allow context-manager usage.\"\"\" return self def __exit__ ( self , exc_type: type [ Exception ], exc: Exception , tb: TracebackType) -> None : \"\"\"Close the connection when leaving a `with` block.\"\"\" self . close()","title":"Connection"},{"location":"api/#snekrpc.transport.Connection.url","text":"Return a string representation of the connection endpoint.","title":"url"},{"location":"api/#snekrpc.transport.Connection.__enter__","text":"Allow context-manager usage. Source code in snekrpc/transport/__init__.py 79 80 81 def __enter__ ( self ) -> 'Connection' : \"\"\"Allow context-manager usage.\"\"\" return self","title":"__enter__"},{"location":"api/#snekrpc.transport.Connection.__exit__","text":"Close the connection when leaving a with block. Source code in snekrpc/transport/__init__.py 83 84 85 def __exit__ ( self , exc_type: type [ Exception ], exc: Exception , tb: TracebackType) -> None : \"\"\"Close the connection when leaving a `with` block.\"\"\" self . close()","title":"__exit__"},{"location":"api/#snekrpc.transport.Connection.__init__","text":"Bind the connection to an interface instance and address. Source code in snekrpc/transport/__init__.py 57 58 59 60 def __init__ ( self , interface: Interface, addr: str ) -> None : \"\"\"Bind the connection to an interface instance and address.\"\"\" self . _ifc = interface self . _addr = addr","title":"__init__"},{"location":"api/#snekrpc.transport.Connection.close","text":"Close the underlying socket/resource. Source code in snekrpc/transport/__init__.py 75 76 77 def close ( self ) -> None : \"\"\"Close the underlying socket/resource.\"\"\" pass","title":"close"},{"location":"api/#snekrpc.transport.Connection.recv","text":"Receive raw bytes. Source code in snekrpc/transport/__init__.py 71 72 73 def recv ( self ) -> bytes : \"\"\"Receive raw bytes.\"\"\" raise NotImplementedError","title":"recv"},{"location":"api/#snekrpc.transport.Connection.send","text":"Send raw bytes. Source code in snekrpc/transport/__init__.py 67 68 69 def send ( self , data: bytes ) -> None : \"\"\"Send raw bytes.\"\"\" raise NotImplementedError","title":"send"},{"location":"api/#snekrpc.transport.Transport","text":"Bases: ABC Base transport class mirrored across clients and servers. Source code in snekrpc/transport/__init__.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Transport (abc . ABC): \"\"\"Base transport class mirrored across clients and servers.\"\"\" def __init_subclass__ ( cls , / , name: str | None = None ) -> None : REGISTRY . set( cls . __name__ if name is None else name, cls ) def __init__ ( self , url: str | utils . url . Url): \"\"\"Store the normalized URL for later use.\"\"\" self . _url = utils . url . Url(url) @property def url ( self ) -> utils . url . Url: \"\"\"Return the configured transport URL.\"\"\" return self . _url @abc . abstractmethod def connect ( self , client: Any) -> Connection: \"\"\"Connect to a remote endpoint and return a Connection.\"\"\" raise NotImplementedError @abc . abstractmethod def serve ( self , server: Any) -> None : \"\"\"Start serving RPC requests.\"\"\" raise NotImplementedError @abc . abstractmethod def stop ( self ) -> None : \"\"\"Stop serving and release resources.\"\"\" raise NotImplementedError @abc . abstractmethod def join ( self , timeout: float | None = None ) -> None : \"\"\"Block until the server threads exit.\"\"\" raise NotImplementedError","title":"Transport"},{"location":"api/#snekrpc.transport.Transport.url","text":"Return the configured transport URL.","title":"url"},{"location":"api/#snekrpc.transport.Transport.__init__","text":"Store the normalized URL for later use. Source code in snekrpc/transport/__init__.py 24 25 26 def __init__ ( self , url: str | utils . url . Url): \"\"\"Store the normalized URL for later use.\"\"\" self . _url = utils . url . Url(url)","title":"__init__"},{"location":"api/#snekrpc.transport.Transport.connect","text":"Connect to a remote endpoint and return a Connection. Source code in snekrpc/transport/__init__.py 33 34 35 36 @abc . abstractmethod def connect ( self , client: Any) -> Connection: \"\"\"Connect to a remote endpoint and return a Connection.\"\"\" raise NotImplementedError","title":"connect"},{"location":"api/#snekrpc.transport.Transport.join","text":"Block until the server threads exit. Source code in snekrpc/transport/__init__.py 48 49 50 51 @abc . abstractmethod def join ( self , timeout: float | None = None ) -> None : \"\"\"Block until the server threads exit.\"\"\" raise NotImplementedError","title":"join"},{"location":"api/#snekrpc.transport.Transport.serve","text":"Start serving RPC requests. Source code in snekrpc/transport/__init__.py 38 39 40 41 @abc . abstractmethod def serve ( self , server: Any) -> None : \"\"\"Start serving RPC requests.\"\"\" raise NotImplementedError","title":"serve"},{"location":"api/#snekrpc.transport.Transport.stop","text":"Stop serving and release resources. Source code in snekrpc/transport/__init__.py 43 44 45 46 @abc . abstractmethod def stop ( self ) -> None : \"\"\"Stop serving and release resources.\"\"\" raise NotImplementedError","title":"stop"},{"location":"api/#snekrpc.transport.create","text":"Create a Transport instance for url . Source code in snekrpc/transport/__init__.py 95 96 97 def create (url: str | utils . url . Url, * args: Any, ** kwargs: Any) -> Transport: \"\"\"Create a `Transport` instance for *url*.\"\"\" return REGISTRY . create(utils . url . Url(url) . scheme, url, * args, ** kwargs) Codec base classes and helpers.","title":"create"},{"location":"api/#snekrpc.codec.Codec","text":"Bases: ABC Base class for codecs that know how to encode/decode RPC payloads. Source code in snekrpc/codec/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Codec (abc . ABC): \"\"\"Base class for codecs that know how to encode/decode RPC payloads.\"\"\" def __init_subclass__ ( cls , / , name: str | None = None ) -> None : REGISTRY . set( cls . __name__ if name is None else name, cls ) @abc . abstractmethod def encode ( self , msg: Any) -> bytes : \"\"\"Serialize `msg` into bytes.\"\"\" raise NotImplementedError ( 'abstract' ) @abc . abstractmethod def decode ( self , data: bytes ) -> Any: \"\"\"Deserialize bytes into Python objects.\"\"\" raise NotImplementedError ( 'abstract' ) def _encode ( self , msg: Any) -> bytes : \"\"\"Wrapper that provides encoding error context. Used internally.\"\"\" try : return self . encode(msg) except Exception as exc: raise errors . EncodeError( f ' { exc } : msg= { utils . format . elide( repr (msg)) } ' ) from exc def _decode ( self , data: bytes ) -> Any: \"\"\"Wrapper that provides decoding error context. Used internally.\"\"\" try : return self . decode(data) except Exception as exc: raise errors . DecodeError( f ' { exc } : data= { utils . format . elide( repr (data)) !r} ' ) from exc","title":"Codec"},{"location":"api/#snekrpc.codec.Codec.decode","text":"Deserialize bytes into Python objects. Source code in snekrpc/codec/__init__.py 23 24 25 26 @abc . abstractmethod def decode ( self , data: bytes ) -> Any: \"\"\"Deserialize bytes into Python objects.\"\"\" raise NotImplementedError ( 'abstract' )","title":"decode"},{"location":"api/#snekrpc.codec.Codec.encode","text":"Serialize msg into bytes. Source code in snekrpc/codec/__init__.py 18 19 20 21 @abc . abstractmethod def encode ( self , msg: Any) -> bytes : \"\"\"Serialize `msg` into bytes.\"\"\" raise NotImplementedError ( 'abstract' ) Formatter plugin infrastructure.","title":"encode"},{"location":"api/#snekrpc.formatter.Formatter","text":"Base class for converting RPC responses to user output. Source code in snekrpc/formatter/__init__.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Formatter : \"\"\"Base class for converting RPC responses to user output.\"\"\" def __init_subclass__ ( cls , / , name: str | None = None ) -> None : REGISTRY . set( cls . __name__ if name is None else name, cls ) def process ( self , res: Any) -> None : \"\"\"Automatically iterate through generators and print results.\"\"\" if inspect . isgenerator(res): for value in res: self . print(value) else : self . print(res) def print ( self , res: Any) -> None : \"\"\"Print a formatted representation of `res`.\"\"\" print ( self . format(res)) def format ( self , res: Any) -> Any: \"\"\"Return the raw value by default; subclasses can override.\"\"\" return res","title":"Formatter"},{"location":"api/#snekrpc.formatter.Formatter.format","text":"Return the raw value by default; subclasses can override. Source code in snekrpc/formatter/__init__.py 29 30 31 def format ( self , res: Any) -> Any: \"\"\"Return the raw value by default; subclasses can override.\"\"\" return res","title":"format"},{"location":"api/#snekrpc.formatter.Formatter.print","text":"Print a formatted representation of res . Source code in snekrpc/formatter/__init__.py 25 26 27 def print ( self , res: Any) -> None : \"\"\"Print a formatted representation of `res`.\"\"\" print ( self . format(res))","title":"print"},{"location":"api/#snekrpc.formatter.Formatter.process","text":"Automatically iterate through generators and print results. Source code in snekrpc/formatter/__init__.py 17 18 19 20 21 22 23 def process ( self , res: Any) -> None : \"\"\"Automatically iterate through generators and print results.\"\"\" if inspect . isgenerator(res): for value in res: self . print(value) else : self . print(res) Command-line entry points for interacting with local and remote servers.","title":"process"},{"location":"api/#snekrpc.cli.Parser","text":"Builds CLI parsers for both client and server workflows. Source code in snekrpc/cli.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 class Parser : \"\"\"Builds CLI parsers for both client and server workflows.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize the base parser and global argument definitions.\"\"\" # global args self . base_parser = argparse . ArgumentParser(add_help =False ) self . add_global_args( self . base_parser) def main ( self ) -> None : \"\"\"Processes command-line arguments and calls any selected command.\"\"\" # temp parser to grab connection arguments parser = argparse . ArgumentParser(add_help =False , parents = [ self . base_parser]) parser . add_argument( '-h' , '--help' , action = 'store_true' , help = 'show this help message and exit' ) parser . add_argument( 'rest' , nargs = argparse . REMAINDER, help = argparse . SUPPRESS) args, extra_args = parser . parse_known_args() logs . init(args . verbose) # import built-in modules registry . init() # import additional modules for imp in args . imports: utils . path . import_module(imp) if args . list: meta = cast( registry . Registry[Any], { 'codecs' : codec . REGISTRY, 'formatters' : formatter . REGISTRY, 'services' : service . REGISTRY, 'transports' : transport . REGISTRY, }[args . list], ) # select an output formatter fmt = None try : fmt = formatter . create(args . format) except Exception as e: if args . verbose: raise parser . error( str (e)) assert fmt is not None fmt . process(meta . names()) return # parser for transport and service args parser = argparse . ArgumentParser(parents = [ self . base_parser]) transport_cls = transport . get(args . url) if isinstance (transport_cls, Exception ): self . add_transport_exception(parser, args . url . scheme, transport_cls) else : self . add_transport_args(parser, transport_cls) # add service arguments used_aliases = set () for name in sorted (args . services): name, alias = parse_alias(name) service_cls = service . get(name) alias = alias or name if alias in used_aliases: raise ValueError ( f 'duplicate service alias: { alias } ' ) used_aliases . add(alias) self . add_service_args(parser, service_cls, alias) # collect transport and service args sub_args = parser . parse_args(extra_args) trn_args, svc_args = self . get_prefixed_args(sub_args) trn_name = args . url . scheme trn = transport . create(args . url, ** trn_args . get(trn_name, {})) # start client or server if args . server_mode: # help if args . help: parser . print_help() parser . exit() if args . version is True : parser . error( 'expected a version string' ) if args . rest: parser . error( 'unrecognized arguments: {} ' . format( ' ' . join(args . rest))) self . start_server(trn, args, svc_args) else : try : self . start_client(trn, parser, args) except Exception as e: err = ' {}\\n connection required for help on remote services' if args . help: parser . print_help() print (err . format(e), file = sys . stderr) parser . exit() if args . verbose: raise parser . error(err . format(e)) def start_client ( self , trn: transport . Transport, parser: argparse . ArgumentParser, args: Args ) -> None : \"\"\"Connect to the remote server and execute a command.\"\"\" client = interface . Client( trn, codec = args . codec, retry_count = args . retry_count, retry_interval = args . retry_interval, ) # get service metadata svcs: list [service . ServiceSpec] | None = None try : meta = client . service( '_meta' ) if args . version: # show server status and exit status = meta . status() self . print_status(status) parser . exit() svcs = msgspec . convert(meta . services(), list [service . ServiceSpec]) except errors . RemoteError as e: if not args . verbose and e . name == 'KeyError' : parser . error( 'metadata service not available' ) raise if svcs is None : # parser.error exits above, but keep type-checkers happy. raise AssertionError ( 'unreachable' ) # add services svc_subs = parser . add_subparsers(title = 'remote services' ) for svc in sorted (svcs, key =lambda s: s . name): svc_name = svc . name svc_desc = self . get_help(svc . doc) svc_parser = svc_subs . add_parser(svc_name, help = svc_desc, description = svc . doc) svc_parser . set_defaults(svc_name = svc_name) # add service commands cmd_subs = svc_parser . add_subparsers(title = 'commands' , dest = 'command' ) cmd_subs . required = True for cmd in svc . commands: cmd_name = cmd . name cmd_desc = self . get_help(cmd . doc) cmd_parser = cmd_subs . add_parser(cmd_name, help = cmd_desc, description = cmd . doc) self . add_command_args(cmd_parser, cmd) cmd_parser . set_defaults(cmd_name = cmd_name, cmd_meta = cmd) # help if args . help: parser . print_help() parser . exit() elif not args . rest: parser . print_usage() parser . exit() # select an output formatter fmt: Any | None = None try : fmt = formatter . create(args . format) except Exception as e: if args . verbose: raise parser . error( str (e)) assert fmt is not None # get the command arguments verbose = args . verbose args = parser . parse_args(args . rest) cmd_args, cmd_kwargs = self . get_command_args(args) # get the command function proxy = client . service(args . svc_name, metadata = [args . cmd_meta]) func = getattr (proxy, args . cmd_name) # call the command try : res = func( * cmd_args, ** cmd_kwargs) assert res is not None fmt . process(res) except Exception as e: if verbose: raise log . error( 'command error: %s ' , e) def start_server ( self , trn: transport . Transport, args: Args, svc_args: dict [ str , dict [ str , Any]], ) -> None : \"\"\"Start an RPC server with the configured services.\"\"\" # create server s = interface . Server( trn, codec = args . codec, version = args . version, remote_tracebacks = args . remote_tracebacks, ) # add services for name in args . services: name, alias = parse_alias(name) s_args = svc_args . get(name, {}) svc = service . create(name, ** s_args) s . add_service(svc, alias) s . serve() ## get arguments ## def get_prefixed_args ( self , args: Args) -> tuple [ dict [ str , Any], dict [ str , Any]]: \"\"\"Split parsed values into transport and service dictionaries.\"\"\" pfx_args: dict [ str , dict [ str , Any]] = {} for name, value in vars (args) . items(): try : prefix, cls_name, arg_name = name . split( '_' , 2 ) except ValueError : continue cls_args = pfx_args . setdefault(prefix, {}) cls_args . setdefault(cls_name, {})[arg_name] = value return pfx_args . get( 'transport' , {}), pfx_args . get( 'service' , {}) def get_command_args ( self , args: Args) -> tuple [ list [Any], dict [ str , Any]]: \"\"\"Processes the command-line arguments and returns the arguments to pass to the selected command.\"\"\" cmd: SignatureSpec = args . cmd_meta cmd_args: list [Any] = [] cmd_kwargs: dict [ str , Any] = {} for param in cmd . parameters: if param . hide: continue arg = getattr (args, param . name) if param . kind in {Param . POSITIONAL_ONLY, Param . POSITIONAL_OR_KEYWORD}: cmd_args . append(arg) elif param . kind == Param . VAR_POSITIONAL: cmd_args . extend(arg) elif param . kind == Param . VAR_KEYWORD: cmd_kwargs . update(arg or {}) elif param . kind == Param . KEYWORD_ONLY: cmd_kwargs[param . name] = arg else : raise AssertionError ( f 'unsupported argument kind: { param . kind } ' ) return cmd_args, cmd_kwargs ## add arguments ## def add_service_args ( self , parser: argparse . ArgumentParser, cls : Any, alias: str ) -> None : \"\"\"Expose ``cls.__init__`` parameters under the given service alias.\"\"\" svc_parser = parser . add_argument_group( ' {} service arguments' . format(alias)) # add a prefix to every param cmd = utils . function . encode( cls . __init__ , remove_self =True ) params = [] for param in cmd . parameters: param = msgspec . structs . replace( param, name = '_' . join([ 'service' , alias, param . name]), # force keyword-only params for clarity kind = param . kind if param . kind == Param . VAR_KEYWORD else Param . KEYWORD_ONLY, ) if not param . has_default: param = msgspec . structs . replace(param, default = argparse . SUPPRESS) params . append(param) self . add_command_args(svc_parser, cmd, single_flags =False ) def add_transport_args ( self , parser: argparse . ArgumentParser, cls : type [transport . Transport] ) -> None : \"\"\"Expose transport constructor parameters with a unique prefix.\"\"\" ignored = { 'url' , 'timeout' } trn_name = transport . REGISTRY . get_name( cls ) trn_parser = parser . add_argument_group( ' {} transport arguments' . format(trn_name), 'To see arguments for another transport, set the \"--url\" argument' , ) # add a prefix to every param cmd = utils . function . encode( cls . __init__ , remove_self =True ) params = [] for param in cmd . parameters: params . append( msgspec . structs . replace( param, name = '_' . join([ 'transport' , trn_name, param . name]), # force keyword-only params for clarity kind = param . kind if param . kind == Param . VAR_KEYWORD else Param . KEYWORD_ONLY, hide = param . name in ignored, ) ) cmd = msgspec . structs . replace(cmd, parameters = tuple (params)) self . add_command_args(trn_parser, cmd, single_flags =False ) def add_transport_exception ( self , parser: argparse . ArgumentParser, name: str , exc: Exception ) -> None : \"\"\"Display an error group when a transport fails to import.\"\"\" parser . add_argument_group( ' {} transport arguments' . format(name), 'failed to load transport: {} ' . format(exc), ) def add_command_args ( self , parser: Any, cmd: SignatureSpec, single_flags: bool = True ) -> None : \"\"\"Translate command metadata into argparse arguments.\"\"\" def is_option_arg (param: ParameterSpec) -> bool : return param . kind == Param . VAR_KEYWORD or param . has_default if single_flags: # keep track of used single char flags chars = set ( 'h' ) # include single char arguments chars . update( p . name for p in cmd . parameters if len (p . name) == 1 and not is_option_arg(p) ) else : chars = None for param in cmd . parameters: name = param . name kind = param . kind hint = param . annotation doc = param . doc if param . hide: continue kwargs: dict [ str , Any] = { 'metavar' : name} if param . has_default: kwargs[ 'default' ] = param . default if kind in {Param . KEYWORD_ONLY, Param . VAR_KEYWORD}: # **kwargs self . add_option_arg(parser, param, chars) elif param . has_default: # args with defaults self . add_option_arg(parser, param, chars) else : # positional args if kind == Param . VAR_POSITIONAL: # *args kwargs[ 'nargs' ] = '*' kwargs . update( { 'type' : self . get_converter(hint), 'help' : self . get_argument_help(doc, hint, param . default), } ) parser . add_argument(name, ** kwargs) def add_option_arg ( self , parser: Any, param: ParameterSpec, chars: set [ str ] | None = None ) -> None : \"\"\"Add an individual option flag, handling bool/kwargs special cases.\"\"\" name = param . name kind = param . kind hint = param . annotation doc = param . doc default = param . default # use dashes instead of underscores for param names flag_name = name . replace( '_' , '-' ) # check for possible short flags flags = [] added = False c = flag_name[ 0 ] C = c . upper() # check if the lower or uppercase char is unique if not chars: # don't add a short flag pass elif c not in chars: flags . append( '-' + c) chars . add(c) added = True elif C not in chars: flags . append( '-' + C) chars . add(C) added = True # add a long flag if no short flag was added # add a long flag if the name is more than 1 character if not added or len (flag_name) > 1 : flags . append( '--' + flag_name) if hint == 'bool' : # handle bool special case group = parser . add_mutually_exclusive_group() if not default: # in case default is None default = False help = self . get_argument_help(doc) # add a flag for the True value group . add_argument( * flags, action = 'store_true' , default = default, dest = name, help = help + ' (default)' if default is True else '' , ) # add a flag for the False value group . add_argument( '--no-' + flag_name, action = 'store_false' , dest = name, help = help + ' (default)' if default is False else '' , ) elif kind == Param . VAR_KEYWORD: parser . add_argument( * flags, action = 'append' , dest = name, type = self . get_converter( 'keyword' ), metavar = 'name=value' , default = default, help = self . get_argument_help(doc, None , default), ) else : parser . add_argument( * flags, dest = name, type = self . get_converter(hint), metavar = self . get_argument_hint(hint), default = default, help = self . get_argument_help(doc, None , default), ) def add_global_args ( self , parser: argparse . ArgumentParser) -> None : \"\"\"Adds an argument group to *parser* for global arguments.\"\"\" egroup = parser . add_mutually_exclusive_group() egroup . add_argument( '-C' , '--client' , action = 'store_false' , dest = 'server_mode' , help = 'start in client mode (default)' , default =False , ) egroup . add_argument( '-S' , '--server' , action = 'store_true' , dest = 'server_mode' , help = 'start in server mode' ) parser . add_argument( '-l' , '--list' , choices = [ 'codecs' , 'formatters' , 'services' , 'transports' ], help = 'list the modules available for the selected category' , ) parser . add_argument( '-v' , '--verbose' , action = 'count' , default = 0 , help = 'enable verbose output (-vv for more)' , ) parser . add_argument( '-V' , '--version' , nargs = '?' , const =True , help = 'show server version (client) or set server version (server)' , ) group = parser . add_argument_group( 'configuration arguments' ) group . add_argument( '-u' , '--url' , type = utils . url . Url, default = utils . DEFAULT_URL, metavar = 'TRANSPORT://HOST:PORT' , help = 'URL to connect or bind to (default: {} )' . format(utils . DEFAULT_URL), ) group . add_argument( '-i' , '--import' , action = 'append' , dest = 'imports' , metavar = 'IMPORT' , default = [], help = 'import an additional (codec/formatter/service/transport) module' , ) group . add_argument( '-c' , '--codec' , help = 'the codec format to use (default: {} on server)' . format(interface . DEFAULT_CODEC), ) group . add_argument( '-s' , '--service' , action = 'append' , dest = 'services' , metavar = 'SERVICE[:alias]' , default = [], help = 'register a service with the server (can be set multiple times)' , ) group = parser . add_argument_group( 'client arguments' ) group . add_argument( '-t' , '--timeout' , type = float , help = 'number of seconds to wait for a response (default: no timeout)' , ) group . add_argument( '-r' , '--retry-count' , type = int , help = 'number of retry attempts to make (-1 for unlimited, default: no retries)' , ) group . add_argument( '--retry-interval' , type = float , help = 'number of seconds between retry attempts (default: 1.0)' , ) group = parser . add_argument_group( 'server arguments' ) group . add_argument( '--remote-tracebacks' , action = 'store_true' , help = 'send tracebacks with errors' ) group = parser . add_argument_group( 'output arguments' ) format_default = { 'piped' : 'json' , 'redirected' : 'raw' , 'terminal' : 'pretty' , }[io_stat_mode()] group . add_argument( '-f' , '--format' , default = format_default, help = 'select a formatter by name or provide a custom Formatter ' \"subclass (default: 'pretty' on terminals, \" \"'json' when piped, and 'raw' when redirected)\" , ) ## parser help ## def get_help ( self , doc: str | None ) -> str : \"\"\"Return the first line of a documentation string.\"\"\" doc = doc or ' \\n ' return doc . splitlines()[ 0 ] def get_argument_help ( self , doc: str | None = None , hint: str | None = None , default: Any = None ) -> str : \"\"\"Build an argparse help string that includes hints and defaults.\"\"\" if is_stream_hint(hint): hint = \"path or '-' for stdin\" help = '< {} >' . format(hint) if hint else '' if doc: help = ' {} {} ' . format(doc, help) if default not in [Param . empty, argparse . SUPPRESS, None ]: help += ' (default: {} )' . format(default) return help def get_argument_hint ( self , hint: str | None ) -> str : \"\"\"Return a placeholder string usable as metavar text.\"\"\" if not hint: return '<str>' elif hint in COLLECTION_TYPES: return '<path or JSON>' else : return '< {} >' . format(hint) ## parser utils ## def get_converter ( self , hint: str | None ) -> Callable[[ str ], Any]: \"\"\"Returns a type converter keyed to a specific typehint.\"\"\" if hint == 'int' : def conv (value: str ) -> Any: return int (value) elif hint == 'float' : def conv (value: str ) -> Any: return float (value) elif hint == 'bytes' : def conv (value: str ) -> Any: return value . encode() elif is_stream_hint(hint): def conv (value: str ) -> Any: fp = cast(BinaryIO, argparse . FileType( 'rb' )(value)) return utils . path . iter_file(fp) elif hint == 'keyword' : def conv (value: str ) -> Any: return value . split( '=' , 1 ) elif hint == 'datetime' : def conv (value: str ) -> Any: try : return datetime . datetime . strptime(value, DATETIME_FORMAT) except ValueError : try : return datetime . datetime . strptime(value, DATE_FORMAT) except Exception : return datetime . datetime . combine( datetime . date . today(), datetime . datetime . strptime(value, TIME_FORMAT) . time(), ) elif hint == 'stream' : def conv (value: str ) -> Any: return (x for x in value) elif hint in COLLECTION_TYPES: def conv (value: str ) -> Any: try : with open (value) as f: return json . load(f) except Exception : return json . loads(value) else : def conv (value: str ) -> Any: return value # the converter name is used in error messages conv . __name__ = hint or 'str' return conv def print_status ( self , status: dict [ str , Any]) -> None : \"\"\"Prints the server version and status data.\"\"\" # TODO: abide by --format flag width = max ( len (k) for k in status) for k, v in sorted (status . items()): print ( '{:> {} }: {} ' . format(k, width, v or '-' ))","title":"Parser"},{"location":"api/#snekrpc.cli.Parser.__init__","text":"Initialize the base parser and global argument definitions. Source code in snekrpc/cli.py 39 40 41 42 43 def __init__ ( self ) -> None : \"\"\"Initialize the base parser and global argument definitions.\"\"\" # global args self . base_parser = argparse . ArgumentParser(add_help =False ) self . add_global_args( self . base_parser)","title":"__init__"},{"location":"api/#snekrpc.cli.Parser.add_command_args","text":"Translate command metadata into argparse arguments. Source code in snekrpc/cli.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def add_command_args ( self , parser: Any, cmd: SignatureSpec, single_flags: bool = True ) -> None : \"\"\"Translate command metadata into argparse arguments.\"\"\" def is_option_arg (param: ParameterSpec) -> bool : return param . kind == Param . VAR_KEYWORD or param . has_default if single_flags: # keep track of used single char flags chars = set ( 'h' ) # include single char arguments chars . update( p . name for p in cmd . parameters if len (p . name) == 1 and not is_option_arg(p) ) else : chars = None for param in cmd . parameters: name = param . name kind = param . kind hint = param . annotation doc = param . doc if param . hide: continue kwargs: dict [ str , Any] = { 'metavar' : name} if param . has_default: kwargs[ 'default' ] = param . default if kind in {Param . KEYWORD_ONLY, Param . VAR_KEYWORD}: # **kwargs self . add_option_arg(parser, param, chars) elif param . has_default: # args with defaults self . add_option_arg(parser, param, chars) else : # positional args if kind == Param . VAR_POSITIONAL: # *args kwargs[ 'nargs' ] = '*' kwargs . update( { 'type' : self . get_converter(hint), 'help' : self . get_argument_help(doc, hint, param . default), } ) parser . add_argument(name, ** kwargs)","title":"add_command_args"},{"location":"api/#snekrpc.cli.Parser.add_global_args","text":"Adds an argument group to parser for global arguments. Source code in snekrpc/cli.py 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 def add_global_args ( self , parser: argparse . ArgumentParser) -> None : \"\"\"Adds an argument group to *parser* for global arguments.\"\"\" egroup = parser . add_mutually_exclusive_group() egroup . add_argument( '-C' , '--client' , action = 'store_false' , dest = 'server_mode' , help = 'start in client mode (default)' , default =False , ) egroup . add_argument( '-S' , '--server' , action = 'store_true' , dest = 'server_mode' , help = 'start in server mode' ) parser . add_argument( '-l' , '--list' , choices = [ 'codecs' , 'formatters' , 'services' , 'transports' ], help = 'list the modules available for the selected category' , ) parser . add_argument( '-v' , '--verbose' , action = 'count' , default = 0 , help = 'enable verbose output (-vv for more)' , ) parser . add_argument( '-V' , '--version' , nargs = '?' , const =True , help = 'show server version (client) or set server version (server)' , ) group = parser . add_argument_group( 'configuration arguments' ) group . add_argument( '-u' , '--url' , type = utils . url . Url, default = utils . DEFAULT_URL, metavar = 'TRANSPORT://HOST:PORT' , help = 'URL to connect or bind to (default: {} )' . format(utils . DEFAULT_URL), ) group . add_argument( '-i' , '--import' , action = 'append' , dest = 'imports' , metavar = 'IMPORT' , default = [], help = 'import an additional (codec/formatter/service/transport) module' , ) group . add_argument( '-c' , '--codec' , help = 'the codec format to use (default: {} on server)' . format(interface . DEFAULT_CODEC), ) group . add_argument( '-s' , '--service' , action = 'append' , dest = 'services' , metavar = 'SERVICE[:alias]' , default = [], help = 'register a service with the server (can be set multiple times)' , ) group = parser . add_argument_group( 'client arguments' ) group . add_argument( '-t' , '--timeout' , type = float , help = 'number of seconds to wait for a response (default: no timeout)' , ) group . add_argument( '-r' , '--retry-count' , type = int , help = 'number of retry attempts to make (-1 for unlimited, default: no retries)' , ) group . add_argument( '--retry-interval' , type = float , help = 'number of seconds between retry attempts (default: 1.0)' , ) group = parser . add_argument_group( 'server arguments' ) group . add_argument( '--remote-tracebacks' , action = 'store_true' , help = 'send tracebacks with errors' ) group = parser . add_argument_group( 'output arguments' ) format_default = { 'piped' : 'json' , 'redirected' : 'raw' , 'terminal' : 'pretty' , }[io_stat_mode()] group . add_argument( '-f' , '--format' , default = format_default, help = 'select a formatter by name or provide a custom Formatter ' \"subclass (default: 'pretty' on terminals, \" \"'json' when piped, and 'raw' when redirected)\" , )","title":"add_global_args"},{"location":"api/#snekrpc.cli.Parser.add_option_arg","text":"Add an individual option flag, handling bool/kwargs special cases. Source code in snekrpc/cli.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 def add_option_arg ( self , parser: Any, param: ParameterSpec, chars: set [ str ] | None = None ) -> None : \"\"\"Add an individual option flag, handling bool/kwargs special cases.\"\"\" name = param . name kind = param . kind hint = param . annotation doc = param . doc default = param . default # use dashes instead of underscores for param names flag_name = name . replace( '_' , '-' ) # check for possible short flags flags = [] added = False c = flag_name[ 0 ] C = c . upper() # check if the lower or uppercase char is unique if not chars: # don't add a short flag pass elif c not in chars: flags . append( '-' + c) chars . add(c) added = True elif C not in chars: flags . append( '-' + C) chars . add(C) added = True # add a long flag if no short flag was added # add a long flag if the name is more than 1 character if not added or len (flag_name) > 1 : flags . append( '--' + flag_name) if hint == 'bool' : # handle bool special case group = parser . add_mutually_exclusive_group() if not default: # in case default is None default = False help = self . get_argument_help(doc) # add a flag for the True value group . add_argument( * flags, action = 'store_true' , default = default, dest = name, help = help + ' (default)' if default is True else '' , ) # add a flag for the False value group . add_argument( '--no-' + flag_name, action = 'store_false' , dest = name, help = help + ' (default)' if default is False else '' , ) elif kind == Param . VAR_KEYWORD: parser . add_argument( * flags, action = 'append' , dest = name, type = self . get_converter( 'keyword' ), metavar = 'name=value' , default = default, help = self . get_argument_help(doc, None , default), ) else : parser . add_argument( * flags, dest = name, type = self . get_converter(hint), metavar = self . get_argument_hint(hint), default = default, help = self . get_argument_help(doc, None , default), )","title":"add_option_arg"},{"location":"api/#snekrpc.cli.Parser.add_service_args","text":"Expose cls.__init__ parameters under the given service alias. Source code in snekrpc/cli.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def add_service_args ( self , parser: argparse . ArgumentParser, cls : Any, alias: str ) -> None : \"\"\"Expose ``cls.__init__`` parameters under the given service alias.\"\"\" svc_parser = parser . add_argument_group( ' {} service arguments' . format(alias)) # add a prefix to every param cmd = utils . function . encode( cls . __init__ , remove_self =True ) params = [] for param in cmd . parameters: param = msgspec . structs . replace( param, name = '_' . join([ 'service' , alias, param . name]), # force keyword-only params for clarity kind = param . kind if param . kind == Param . VAR_KEYWORD else Param . KEYWORD_ONLY, ) if not param . has_default: param = msgspec . structs . replace(param, default = argparse . SUPPRESS) params . append(param) self . add_command_args(svc_parser, cmd, single_flags =False )","title":"add_service_args"},{"location":"api/#snekrpc.cli.Parser.add_transport_args","text":"Expose transport constructor parameters with a unique prefix. Source code in snekrpc/cli.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def add_transport_args ( self , parser: argparse . ArgumentParser, cls : type [transport . Transport] ) -> None : \"\"\"Expose transport constructor parameters with a unique prefix.\"\"\" ignored = { 'url' , 'timeout' } trn_name = transport . REGISTRY . get_name( cls ) trn_parser = parser . add_argument_group( ' {} transport arguments' . format(trn_name), 'To see arguments for another transport, set the \"--url\" argument' , ) # add a prefix to every param cmd = utils . function . encode( cls . __init__ , remove_self =True ) params = [] for param in cmd . parameters: params . append( msgspec . structs . replace( param, name = '_' . join([ 'transport' , trn_name, param . name]), # force keyword-only params for clarity kind = param . kind if param . kind == Param . VAR_KEYWORD else Param . KEYWORD_ONLY, hide = param . name in ignored, ) ) cmd = msgspec . structs . replace(cmd, parameters = tuple (params)) self . add_command_args(trn_parser, cmd, single_flags =False )","title":"add_transport_args"},{"location":"api/#snekrpc.cli.Parser.add_transport_exception","text":"Display an error group when a transport fails to import. Source code in snekrpc/cli.py 354 355 356 357 358 359 360 361 def add_transport_exception ( self , parser: argparse . ArgumentParser, name: str , exc: Exception ) -> None : \"\"\"Display an error group when a transport fails to import.\"\"\" parser . add_argument_group( ' {} transport arguments' . format(name), 'failed to load transport: {} ' . format(exc), )","title":"add_transport_exception"},{"location":"api/#snekrpc.cli.Parser.get_argument_help","text":"Build an argparse help string that includes hints and defaults. Source code in snekrpc/cli.py 615 616 617 618 619 620 621 622 623 624 625 626 def get_argument_help ( self , doc: str | None = None , hint: str | None = None , default: Any = None ) -> str : \"\"\"Build an argparse help string that includes hints and defaults.\"\"\" if is_stream_hint(hint): hint = \"path or '-' for stdin\" help = '< {} >' . format(hint) if hint else '' if doc: help = ' {} {} ' . format(doc, help) if default not in [Param . empty, argparse . SUPPRESS, None ]: help += ' (default: {} )' . format(default) return help","title":"get_argument_help"},{"location":"api/#snekrpc.cli.Parser.get_argument_hint","text":"Return a placeholder string usable as metavar text. Source code in snekrpc/cli.py 628 629 630 631 632 633 634 635 def get_argument_hint ( self , hint: str | None ) -> str : \"\"\"Return a placeholder string usable as metavar text.\"\"\" if not hint: return '<str>' elif hint in COLLECTION_TYPES: return '<path or JSON>' else : return '< {} >' . format(hint)","title":"get_argument_hint"},{"location":"api/#snekrpc.cli.Parser.get_command_args","text":"Processes the command-line arguments and returns the arguments to pass to the selected command. Source code in snekrpc/cli.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def get_command_args ( self , args: Args) -> tuple [ list [Any], dict [ str , Any]]: \"\"\"Processes the command-line arguments and returns the arguments to pass to the selected command.\"\"\" cmd: SignatureSpec = args . cmd_meta cmd_args: list [Any] = [] cmd_kwargs: dict [ str , Any] = {} for param in cmd . parameters: if param . hide: continue arg = getattr (args, param . name) if param . kind in {Param . POSITIONAL_ONLY, Param . POSITIONAL_OR_KEYWORD}: cmd_args . append(arg) elif param . kind == Param . VAR_POSITIONAL: cmd_args . extend(arg) elif param . kind == Param . VAR_KEYWORD: cmd_kwargs . update(arg or {}) elif param . kind == Param . KEYWORD_ONLY: cmd_kwargs[param . name] = arg else : raise AssertionError ( f 'unsupported argument kind: { param . kind } ' ) return cmd_args, cmd_kwargs","title":"get_command_args"},{"location":"api/#snekrpc.cli.Parser.get_converter","text":"Returns a type converter keyed to a specific typehint. Source code in snekrpc/cli.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 def get_converter ( self , hint: str | None ) -> Callable[[ str ], Any]: \"\"\"Returns a type converter keyed to a specific typehint.\"\"\" if hint == 'int' : def conv (value: str ) -> Any: return int (value) elif hint == 'float' : def conv (value: str ) -> Any: return float (value) elif hint == 'bytes' : def conv (value: str ) -> Any: return value . encode() elif is_stream_hint(hint): def conv (value: str ) -> Any: fp = cast(BinaryIO, argparse . FileType( 'rb' )(value)) return utils . path . iter_file(fp) elif hint == 'keyword' : def conv (value: str ) -> Any: return value . split( '=' , 1 ) elif hint == 'datetime' : def conv (value: str ) -> Any: try : return datetime . datetime . strptime(value, DATETIME_FORMAT) except ValueError : try : return datetime . datetime . strptime(value, DATE_FORMAT) except Exception : return datetime . datetime . combine( datetime . date . today(), datetime . datetime . strptime(value, TIME_FORMAT) . time(), ) elif hint == 'stream' : def conv (value: str ) -> Any: return (x for x in value) elif hint in COLLECTION_TYPES: def conv (value: str ) -> Any: try : with open (value) as f: return json . load(f) except Exception : return json . loads(value) else : def conv (value: str ) -> Any: return value # the converter name is used in error messages conv . __name__ = hint or 'str' return conv","title":"get_converter"},{"location":"api/#snekrpc.cli.Parser.get_help","text":"Return the first line of a documentation string. Source code in snekrpc/cli.py 610 611 612 613 def get_help ( self , doc: str | None ) -> str : \"\"\"Return the first line of a documentation string.\"\"\" doc = doc or ' \\n ' return doc . splitlines()[ 0 ]","title":"get_help"},{"location":"api/#snekrpc.cli.Parser.get_prefixed_args","text":"Split parsed values into transport and service dictionaries. Source code in snekrpc/cli.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def get_prefixed_args ( self , args: Args) -> tuple [ dict [ str , Any], dict [ str , Any]]: \"\"\"Split parsed values into transport and service dictionaries.\"\"\" pfx_args: dict [ str , dict [ str , Any]] = {} for name, value in vars (args) . items(): try : prefix, cls_name, arg_name = name . split( '_' , 2 ) except ValueError : continue cls_args = pfx_args . setdefault(prefix, {}) cls_args . setdefault(cls_name, {})[arg_name] = value return pfx_args . get( 'transport' , {}), pfx_args . get( 'service' , {})","title":"get_prefixed_args"},{"location":"api/#snekrpc.cli.Parser.main","text":"Processes command-line arguments and calls any selected command. Source code in snekrpc/cli.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def main ( self ) -> None : \"\"\"Processes command-line arguments and calls any selected command.\"\"\" # temp parser to grab connection arguments parser = argparse . ArgumentParser(add_help =False , parents = [ self . base_parser]) parser . add_argument( '-h' , '--help' , action = 'store_true' , help = 'show this help message and exit' ) parser . add_argument( 'rest' , nargs = argparse . REMAINDER, help = argparse . SUPPRESS) args, extra_args = parser . parse_known_args() logs . init(args . verbose) # import built-in modules registry . init() # import additional modules for imp in args . imports: utils . path . import_module(imp) if args . list: meta = cast( registry . Registry[Any], { 'codecs' : codec . REGISTRY, 'formatters' : formatter . REGISTRY, 'services' : service . REGISTRY, 'transports' : transport . REGISTRY, }[args . list], ) # select an output formatter fmt = None try : fmt = formatter . create(args . format) except Exception as e: if args . verbose: raise parser . error( str (e)) assert fmt is not None fmt . process(meta . names()) return # parser for transport and service args parser = argparse . ArgumentParser(parents = [ self . base_parser]) transport_cls = transport . get(args . url) if isinstance (transport_cls, Exception ): self . add_transport_exception(parser, args . url . scheme, transport_cls) else : self . add_transport_args(parser, transport_cls) # add service arguments used_aliases = set () for name in sorted (args . services): name, alias = parse_alias(name) service_cls = service . get(name) alias = alias or name if alias in used_aliases: raise ValueError ( f 'duplicate service alias: { alias } ' ) used_aliases . add(alias) self . add_service_args(parser, service_cls, alias) # collect transport and service args sub_args = parser . parse_args(extra_args) trn_args, svc_args = self . get_prefixed_args(sub_args) trn_name = args . url . scheme trn = transport . create(args . url, ** trn_args . get(trn_name, {})) # start client or server if args . server_mode: # help if args . help: parser . print_help() parser . exit() if args . version is True : parser . error( 'expected a version string' ) if args . rest: parser . error( 'unrecognized arguments: {} ' . format( ' ' . join(args . rest))) self . start_server(trn, args, svc_args) else : try : self . start_client(trn, parser, args) except Exception as e: err = ' {}\\n connection required for help on remote services' if args . help: parser . print_help() print (err . format(e), file = sys . stderr) parser . exit() if args . verbose: raise parser . error(err . format(e))","title":"main"},{"location":"api/#snekrpc.cli.Parser.print_status","text":"Prints the server version and status data. Source code in snekrpc/cli.py 697 698 699 700 701 702 def print_status ( self , status: dict [ str , Any]) -> None : \"\"\"Prints the server version and status data.\"\"\" # TODO: abide by --format flag width = max ( len (k) for k in status) for k, v in sorted (status . items()): print ( '{:> {} }: {} ' . format(k, width, v or '-' ))","title":"print_status"},{"location":"api/#snekrpc.cli.Parser.start_client","text":"Connect to the remote server and execute a command. Source code in snekrpc/cli.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def start_client ( self , trn: transport . Transport, parser: argparse . ArgumentParser, args: Args ) -> None : \"\"\"Connect to the remote server and execute a command.\"\"\" client = interface . Client( trn, codec = args . codec, retry_count = args . retry_count, retry_interval = args . retry_interval, ) # get service metadata svcs: list [service . ServiceSpec] | None = None try : meta = client . service( '_meta' ) if args . version: # show server status and exit status = meta . status() self . print_status(status) parser . exit() svcs = msgspec . convert(meta . services(), list [service . ServiceSpec]) except errors . RemoteError as e: if not args . verbose and e . name == 'KeyError' : parser . error( 'metadata service not available' ) raise if svcs is None : # parser.error exits above, but keep type-checkers happy. raise AssertionError ( 'unreachable' ) # add services svc_subs = parser . add_subparsers(title = 'remote services' ) for svc in sorted (svcs, key =lambda s: s . name): svc_name = svc . name svc_desc = self . get_help(svc . doc) svc_parser = svc_subs . add_parser(svc_name, help = svc_desc, description = svc . doc) svc_parser . set_defaults(svc_name = svc_name) # add service commands cmd_subs = svc_parser . add_subparsers(title = 'commands' , dest = 'command' ) cmd_subs . required = True for cmd in svc . commands: cmd_name = cmd . name cmd_desc = self . get_help(cmd . doc) cmd_parser = cmd_subs . add_parser(cmd_name, help = cmd_desc, description = cmd . doc) self . add_command_args(cmd_parser, cmd) cmd_parser . set_defaults(cmd_name = cmd_name, cmd_meta = cmd) # help if args . help: parser . print_help() parser . exit() elif not args . rest: parser . print_usage() parser . exit() # select an output formatter fmt: Any | None = None try : fmt = formatter . create(args . format) except Exception as e: if args . verbose: raise parser . error( str (e)) assert fmt is not None # get the command arguments verbose = args . verbose args = parser . parse_args(args . rest) cmd_args, cmd_kwargs = self . get_command_args(args) # get the command function proxy = client . service(args . svc_name, metadata = [args . cmd_meta]) func = getattr (proxy, args . cmd_name) # call the command try : res = func( * cmd_args, ** cmd_kwargs) assert res is not None fmt . process(res) except Exception as e: if verbose: raise log . error( 'command error: %s ' , e)","title":"start_client"},{"location":"api/#snekrpc.cli.Parser.start_server","text":"Start an RPC server with the configured services. Source code in snekrpc/cli.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def start_server ( self , trn: transport . Transport, args: Args, svc_args: dict [ str , dict [ str , Any]], ) -> None : \"\"\"Start an RPC server with the configured services.\"\"\" # create server s = interface . Server( trn, codec = args . codec, version = args . version, remote_tracebacks = args . remote_tracebacks, ) # add services for name in args . services: name, alias = parse_alias(name) s_args = svc_args . get(name, {}) svc = service . create(name, ** s_args) s . add_service(svc, alias) s . serve()","title":"start_server"},{"location":"api/#snekrpc.cli.io_stat_mode","text":"Return whether stdout is piped, redirected, or connected to a tty. Source code in snekrpc/cli.py 723 724 725 726 727 728 729 730 731 def io_stat_mode () -> str : \"\"\"Return whether stdout is piped, redirected, or connected to a tty.\"\"\" mode = os . fstat(sys . stdout . fileno()) . st_mode if stat . S_ISFIFO(mode): return 'piped' elif stat . S_ISREG(mode): return 'redirected' else : return 'terminal'","title":"io_stat_mode"},{"location":"api/#snekrpc.cli.main","text":"Convenient entry-point. Source code in snekrpc/cli.py 31 32 33 def main () -> None : \"\"\"Convenient entry-point.\"\"\" Parser() . main()","title":"main"},{"location":"api/#snekrpc.cli.parse_alias","text":"Split name into module and alias if : is present. Source code in snekrpc/cli.py 710 711 712 713 714 715 716 def parse_alias (name: str ) -> tuple [ str , str | None ]: \"\"\"Split ``name`` into ``module`` and ``alias`` if ``:`` is present.\"\"\" try : base, alias = name . split( ':' ) except ValueError : return name, None return base, alias","title":"parse_alias"},{"location":"client/","text":"Client \u00b6 API \u00b6 A server is created by setting a URL to define the transport to use, as well as the host and port to connect to (default: tcp://127.0.0.1:12321 ). client = snekrpc . Client( 'tcp://127.0.0.1:12321' ) svc = client . service( 'echo' ) print (svc . echo( 'hello' )) By default, the client will initiate a handshake with the server in order to determine which codec to use. This can be skipped by setting the codec directly. The client will connect on the first attempt to interact with the server. In this case, that is the call to service() . service() returns a proxy object which can be used to call service methods directly. As a convenience, services are also accessible as attributes on the Client instance, however the service() method is required when service names conflict with Client method names. print (client . echo . echo( 'hello' )) Retry behavior: client = snekrpc . Client(retry_count = 3 , retry_interval = 0.5 ) CLI \u00b6 The snekrpc CLI can connect to any server with a supported transport and codec. $ snekrpc --url http://127.0.0.1:8000 --codec json echo echo hello # use default transport and codec $ snekrpc health ping --count 3 Arguments will be defined for every service command argument. Command-line help will also be fully populated. $ snekrpc health ping -h usage: snekrpc health ping [ -h ] [ -c <int> ] [ -i <float> ] Respond at regular intervals. options: -h, --help show this help message and exit -c, --count <int> ( default: 1 ) -i, --interval <float> ( default: 1 .0 ) Streaming \u00b6 When a command expects a stream, the CLI accepts a file path or - for stdin. $ snekrpc file upload ./local.bin remote.bin $ snekrpc file upload - remote.bin < ./local.bin","title":"Client"},{"location":"client/#client","text":"","title":"Client"},{"location":"client/#api","text":"A server is created by setting a URL to define the transport to use, as well as the host and port to connect to (default: tcp://127.0.0.1:12321 ). client = snekrpc . Client( 'tcp://127.0.0.1:12321' ) svc = client . service( 'echo' ) print (svc . echo( 'hello' )) By default, the client will initiate a handshake with the server in order to determine which codec to use. This can be skipped by setting the codec directly. The client will connect on the first attempt to interact with the server. In this case, that is the call to service() . service() returns a proxy object which can be used to call service methods directly. As a convenience, services are also accessible as attributes on the Client instance, however the service() method is required when service names conflict with Client method names. print (client . echo . echo( 'hello' )) Retry behavior: client = snekrpc . Client(retry_count = 3 , retry_interval = 0.5 )","title":"API"},{"location":"client/#cli","text":"The snekrpc CLI can connect to any server with a supported transport and codec. $ snekrpc --url http://127.0.0.1:8000 --codec json echo echo hello # use default transport and codec $ snekrpc health ping --count 3 Arguments will be defined for every service command argument. Command-line help will also be fully populated. $ snekrpc health ping -h usage: snekrpc health ping [ -h ] [ -c <int> ] [ -i <float> ] Respond at regular intervals. options: -h, --help show this help message and exit -c, --count <int> ( default: 1 ) -i, --interval <float> ( default: 1 .0 )","title":"CLI"},{"location":"client/#streaming","text":"When a command expects a stream, the CLI accepts a file path or - for stdin. $ snekrpc file upload ./local.bin remote.bin $ snekrpc file upload - remote.bin < ./local.bin","title":"Streaming"},{"location":"protocol/","text":"","title":"Protocol"},{"location":"server/","text":"Server \u00b6 API \u00b6 A snekrpc server hosts a number of services. A service is defined by subclassing Service and marking some methods with command() . The class argument name is optional, but recommended in order to register a definitive name with the snekrpc system. import snekrpc class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value A server is created by setting a URL to define the transport to use, as well as the interface and port to bind to (default: tcp://127.0.0.1:12321 ). A codec can also be set for encoding/decoding to/from bytes for transfer over the transport (default: msgpack ). Once a Server instance has been created, you can add services with the add_service() method, which will expose the service using the name set in the class definition. server = snekrpc . Server( 'tcp://0.0.0.0:12321' , codec = 'json' ) server . add_service(EchoService()) server . serve() Notes: The server registers a hidden _meta service automatically to provide metadata to clients. add_service() accepts an name argument if you want the service exposed under a different name. Server(remote_tracebacks=True) will include tracebacks in error responses. Command metadata \u00b6 The clients rely on command metadata to fill in front-end details. Use param() for parameter docs or to hide parameters from display in help output. class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value Streaming \u00b6 If a command returns a generator, the values yielde d will be streamed to clients. If the first argument (and only the first argument) passed into a command is a generator, values will stream in from the client. class StreamService (snekrpc . Service, name = 'stream' ): @snekrpc . command() def echo ( self , values: Iterable[ str ]) -> Iterable[ str ]: yield from values CLI \u00b6 A server can also be started directly with the snekrpc CLI using the -S,--server flag. Services are added using -s,--service . # bind with the default: tcp://127.0.0.1:12321 $ snekrpc --server --service health --service file $ snekrpc --server --url unix:///tmp/snekrpc.sock --service health Only Service classes which have been registered will be available. There are a few built-in services (use snekrpc --list services to see them). Others can be added by module path and optionally given a different name by appending :<name> : $ snekrpc --server --service echo_service.EchoService:echo You can also import a module directly, in which case the service can be referenced by it's registered name: $ snekrpc --server --import echo_service --service echo","title":"Server"},{"location":"server/#server","text":"","title":"Server"},{"location":"server/#api","text":"A snekrpc server hosts a number of services. A service is defined by subclassing Service and marking some methods with command() . The class argument name is optional, but recommended in order to register a definitive name with the snekrpc system. import snekrpc class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value A server is created by setting a URL to define the transport to use, as well as the interface and port to bind to (default: tcp://127.0.0.1:12321 ). A codec can also be set for encoding/decoding to/from bytes for transfer over the transport (default: msgpack ). Once a Server instance has been created, you can add services with the add_service() method, which will expose the service using the name set in the class definition. server = snekrpc . Server( 'tcp://0.0.0.0:12321' , codec = 'json' ) server . add_service(EchoService()) server . serve() Notes: The server registers a hidden _meta service automatically to provide metadata to clients. add_service() accepts an name argument if you want the service exposed under a different name. Server(remote_tracebacks=True) will include tracebacks in error responses.","title":"API"},{"location":"server/#command-metadata","text":"The clients rely on command metadata to fill in front-end details. Use param() for parameter docs or to hide parameters from display in help output. class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value","title":"Command metadata"},{"location":"server/#streaming","text":"If a command returns a generator, the values yielde d will be streamed to clients. If the first argument (and only the first argument) passed into a command is a generator, values will stream in from the client. class StreamService (snekrpc . Service, name = 'stream' ): @snekrpc . command() def echo ( self , values: Iterable[ str ]) -> Iterable[ str ]: yield from values","title":"Streaming"},{"location":"server/#cli","text":"A server can also be started directly with the snekrpc CLI using the -S,--server flag. Services are added using -s,--service . # bind with the default: tcp://127.0.0.1:12321 $ snekrpc --server --service health --service file $ snekrpc --server --url unix:///tmp/snekrpc.sock --service health Only Service classes which have been registered will be available. There are a few built-in services (use snekrpc --list services to see them). Others can be added by module path and optionally given a different name by appending :<name> : $ snekrpc --server --service echo_service.EchoService:echo You can also import a module directly, in which case the service can be referenced by it's registered name: $ snekrpc --server --import echo_service --service echo","title":"CLI"},{"location":"services/","text":"Services \u00b6 Services group related RPC commands. A server holds a registry of service instances and exposes them by name. Commands are normal Python callables decorated with @snekrpc.command() . Defining a service \u00b6 import snekrpc class MathService (snekrpc . Service, name = 'math' ): @snekrpc . command() def add ( self , a: int , b: int ) -> int : return a + b server = snekrpc . Server() server . add_service(MathService()) server . serve() Built-in services \u00b6 Metadata ( meta / _meta ) \u00b6 The metadata service is automatically registered by the server under the alias _meta . It reports codec/transport information and provides command metadata used by the client and CLI. Commands include: status() service_names() services() service(name) Health ( health ) \u00b6 The health service provides a ping generator that yields regularly to keep a connection alive. File ( file ) \u00b6 The file service exposes basic filesystem operations including paths , upload , and download . By default, it uses safe_root=True to prevent path traversal beyond the configured root_path . Remote ( remote ) \u00b6 The remote service forwards calls to another endpoint by creating a nested client and exposing it under a new service name. Loading services from the CLI \u00b6 You can add services by name or by import path. $ snekrpc --server --service health --service file $ snekrpc --server --service mypkg.services.CustomService:alias","title":"Services"},{"location":"services/#services","text":"Services group related RPC commands. A server holds a registry of service instances and exposes them by name. Commands are normal Python callables decorated with @snekrpc.command() .","title":"Services"},{"location":"services/#defining-a-service","text":"import snekrpc class MathService (snekrpc . Service, name = 'math' ): @snekrpc . command() def add ( self , a: int , b: int ) -> int : return a + b server = snekrpc . Server() server . add_service(MathService()) server . serve()","title":"Defining a service"},{"location":"services/#built-in-services","text":"","title":"Built-in services"},{"location":"services/#metadata-meta-_meta","text":"The metadata service is automatically registered by the server under the alias _meta . It reports codec/transport information and provides command metadata used by the client and CLI. Commands include: status() service_names() services() service(name)","title":"Metadata (meta / _meta)"},{"location":"services/#health-health","text":"The health service provides a ping generator that yields regularly to keep a connection alive.","title":"Health (health)"},{"location":"services/#file-file","text":"The file service exposes basic filesystem operations including paths , upload , and download . By default, it uses safe_root=True to prevent path traversal beyond the configured root_path .","title":"File (file)"},{"location":"services/#remote-remote","text":"The remote service forwards calls to another endpoint by creating a nested client and exposing it under a new service name.","title":"Remote (remote)"},{"location":"services/#loading-services-from-the-cli","text":"You can add services by name or by import path. $ snekrpc --server --service health --service file $ snekrpc --server --service mypkg.services.CustomService:alias","title":"Loading services from the CLI"}]}