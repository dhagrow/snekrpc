{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"snekrpc \u00b6 snekrpc is a lightweight Python RPC toolkit focused on fast prototyping for microservices and distributed systems. It ships a small core, with pluggable transports and codecs. A client-side Python library and CLI are generated at runtime based on metadata from services. Features \u00b6 Simple service model with metadata and runtime introspection Bi-directional streaming Built-in transports: TCP, Unix domain sockets, and HTTP (not REST) Built-in codecs: JSON and MessagePack (based on msgspec ) Built-in services: health , file , and remote (service pivoting/forwarding) Runtime generated client API Runtime generated client CLI Pre-generated typed client API Requirements \u00b6 Python 3.11+. Installation \u00b6 $ pip install snekrpc For development: $ git clone https://github.com/dhagrow/snekrpc.git $ cd snekrpc $ uv sync Quick start \u00b6 Define a service and start a server \u00b6 import snekrpc class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value server = snekrpc . Server() server . add_service(EchoService()) server . serve() The server will bind to tcp://127.0.0.1:12321 , by default. The client API and CLI will also connect to this, by default. You can pass in a different address in the same URL format, where the scheme determines the transport to use (e.g. http://localhost:5000 ). Call with a client API \u00b6 import snekrpc client = snekrpc . Client() echo_svc = client . service( 'echo' ) print (echo_svc . echo( 'hello' )) Call with a client CLI \u00b6 List available services and call a command: $ snekrpc usage: snekrpc [ -h ] ... { echo } ... # snekrpc <service-name> <command-name> <command-argument> $ snekrpc echo echo hello hello Streaming \u00b6 If a command accepts or returns an iterable/generator, it is streamed over the transport. Note that streaming to the server is only supported in the first argument of a command. class FileService (snekrpc . Service, name = 'file' ): @snekrpc . command() def download ( self , path: str ) -> Iterable[ bytes ]: with open (path, 'rb' ) as fp: for chunk in iter ( lambda : fp . read( 8192 ), b '' ): yield chunk @snekrpc . command() def upload ( self , data: Iterable[ bytes ], path: str ) -> None : with open (path, 'wb' ) as fp: for chunk in data: fp . write(chunk) On the CLI, streaming arguments accept a file path or - for stdin. What about asyncio ? \u00b6 There is not currently any support provided for asyncio . This is primarily due to the fact that I don't personally use asyncio in either my personal or professional work. Where I need asynchronous IO, I first reach for gevent . However I have found fewer and fewer appropriate use-cases for it over the years. I'm not opposed to making changes that simplify the integration of snekrpc with a project that uses asyncio , and will consider any PR to that end. However, I'm not willing to take on the maintenance burden of a feature I don't need or use. Besides, I'd rather be working on the projects this library enables. AI disclosure \u00b6 I used AI to support some of the documentation for this project. I reviewed all of it and rewrote much of it. I have not yet used AI to write any of the code, though I do have branches I may experiment with. Contributing \u00b6 Issues and pull requests are welcome. Please include tests for behavioral changes and keep the public API backwards compatible where possible. I'd like to be able License \u00b6 MIT","title":"Home"},{"location":"#snekrpc","text":"snekrpc is a lightweight Python RPC toolkit focused on fast prototyping for microservices and distributed systems. It ships a small core, with pluggable transports and codecs. A client-side Python library and CLI are generated at runtime based on metadata from services.","title":"snekrpc"},{"location":"#features","text":"Simple service model with metadata and runtime introspection Bi-directional streaming Built-in transports: TCP, Unix domain sockets, and HTTP (not REST) Built-in codecs: JSON and MessagePack (based on msgspec ) Built-in services: health , file , and remote (service pivoting/forwarding) Runtime generated client API Runtime generated client CLI Pre-generated typed client API","title":"Features"},{"location":"#requirements","text":"Python 3.11+.","title":"Requirements"},{"location":"#installation","text":"$ pip install snekrpc For development: $ git clone https://github.com/dhagrow/snekrpc.git $ cd snekrpc $ uv sync","title":"Installation"},{"location":"#quick-start","text":"","title":"Quick start"},{"location":"#define-a-service-and-start-a-server","text":"import snekrpc class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value server = snekrpc . Server() server . add_service(EchoService()) server . serve() The server will bind to tcp://127.0.0.1:12321 , by default. The client API and CLI will also connect to this, by default. You can pass in a different address in the same URL format, where the scheme determines the transport to use (e.g. http://localhost:5000 ).","title":"Define a service and start a server"},{"location":"#call-with-a-client-api","text":"import snekrpc client = snekrpc . Client() echo_svc = client . service( 'echo' ) print (echo_svc . echo( 'hello' ))","title":"Call with a client API"},{"location":"#call-with-a-client-cli","text":"List available services and call a command: $ snekrpc usage: snekrpc [ -h ] ... { echo } ... # snekrpc <service-name> <command-name> <command-argument> $ snekrpc echo echo hello hello","title":"Call with a client CLI"},{"location":"#streaming","text":"If a command accepts or returns an iterable/generator, it is streamed over the transport. Note that streaming to the server is only supported in the first argument of a command. class FileService (snekrpc . Service, name = 'file' ): @snekrpc . command() def download ( self , path: str ) -> Iterable[ bytes ]: with open (path, 'rb' ) as fp: for chunk in iter ( lambda : fp . read( 8192 ), b '' ): yield chunk @snekrpc . command() def upload ( self , data: Iterable[ bytes ], path: str ) -> None : with open (path, 'wb' ) as fp: for chunk in data: fp . write(chunk) On the CLI, streaming arguments accept a file path or - for stdin.","title":"Streaming"},{"location":"#what-about-asyncio","text":"There is not currently any support provided for asyncio . This is primarily due to the fact that I don't personally use asyncio in either my personal or professional work. Where I need asynchronous IO, I first reach for gevent . However I have found fewer and fewer appropriate use-cases for it over the years. I'm not opposed to making changes that simplify the integration of snekrpc with a project that uses asyncio , and will consider any PR to that end. However, I'm not willing to take on the maintenance burden of a feature I don't need or use. Besides, I'd rather be working on the projects this library enables.","title":"What about asyncio?"},{"location":"#ai-disclosure","text":"I used AI to support some of the documentation for this project. I reviewed all of it and rewrote much of it. I have not yet used AI to write any of the code, though I do have branches I may experiment with.","title":"AI disclosure"},{"location":"#contributing","text":"Issues and pull requests are welcome. Please include tests for behavioral changes and keep the public API backwards compatible where possible. I'd like to be able","title":"Contributing"},{"location":"#license","text":"MIT","title":"License"},{"location":"api/","text":"API Reference \u00b6 Server \u00b6 Bases: Interface add_service(service, name =None ) \u00b6 Register a service with the server. You can register a service but keep it hidden from users by prefixing the name with an underscore. Service base classes and helpers. ServiceProxy \u00b6 Client-side helper that exposes remote commands as callables. __dir__ () \u00b6 Add remote command names to dir() results. __getattr__ (cmd_name) \u00b6 Return a cached callable or lazily wrap the remote command. __init__ (name, client, command_metadata =True ) \u00b6 Cache remote service metadata and wrap remote commands. When command_metadata is True , metadata will be loaded from the remote metadata service. When False , no metadata will be loaded. Otherwise, a sequence of command metadata can be provided directly. ServiceSpec \u00b6 Bases: Struct Description of a callable signature. from_service(svc, service_name =None ) classmethod \u00b6 Serialize a service definition for metadata responses. StreamInitiator \u00b6 Generator shim that ensures the generator is started. __init__ (gen) \u00b6 Prime the generator while preserving the first item. __iter__ () \u00b6 Yield the cached first item followed by the original stream. wrap_call(proxy, cmd_name, cmd_spec =None ) \u00b6 Wrap a remote call in retry logic, handling stream outputs. Base transport abstractions. Connection \u00b6 Wrap an underlying socket-like object and handle message encoding. url property \u00b6 Return a string representation of the connection endpoint. __enter__ () \u00b6 Allow context-manager usage. __exit__ (exc_type, exc, tb) \u00b6 Close the connection when leaving a with block. __init__ (interface, addr) \u00b6 Bind the connection to an interface instance and address. close() \u00b6 Close the underlying socket/resource. recv() \u00b6 Receive raw bytes. send(data) \u00b6 Send raw bytes. Transport \u00b6 Bases: ABC Base transport class mirrored across clients and servers. url property \u00b6 Return the configured transport URL. __init__ (url) \u00b6 Store the normalized URL for later use. connect(client) abstractmethod \u00b6 Connect to a remote endpoint and return a Connection. join(timeout =None ) abstractmethod \u00b6 Block until the server threads exit. serve(server) abstractmethod \u00b6 Start serving RPC requests. stop() abstractmethod \u00b6 Stop serving and release resources. create(url, * args, ** kwargs) \u00b6 Create a Transport instance for url . Codec base classes and helpers. Codec \u00b6 Bases: ABC Base class for codecs that know how to encode/decode RPC payloads. decode(data) abstractmethod \u00b6 Deserialize bytes into Python objects. encode(msg) abstractmethod \u00b6 Serialize msg into bytes. Formatter plugin infrastructure. Formatter \u00b6 Base class for converting RPC responses to user output. format (res) \u00b6 Return the raw value by default; subclasses can override. print (res) \u00b6 Print a formatted representation of res . process(res) \u00b6 Automatically iterate through generators and print results. Command-line entry points for interacting with local and remote servers. Parser \u00b6 Builds CLI parsers for both client and server workflows. __init__ () \u00b6 Initialize the base parser and global argument definitions. add_command_args(parser, cmd, single_flags =True ) \u00b6 Translate command metadata into argparse arguments. add_global_args(parser) \u00b6 Adds an argument group to parser for global arguments. add_option_arg(parser, param, chars =None ) \u00b6 Add an individual option flag, handling bool/kwargs special cases. add_service_args(parser, cls , alias) \u00b6 Expose cls.__init__ parameters under the given service alias. add_transport_args(parser, cls ) \u00b6 Expose transport constructor parameters with a unique prefix. add_transport_exception(parser, name, exc) \u00b6 Display an error group when a transport fails to import. get_argument_help(doc =None , hint =None , default =None ) \u00b6 Build an argparse help string that includes hints and defaults. get_argument_hint(hint) \u00b6 Return a placeholder string usable as metavar text. get_command_args(args) \u00b6 Processes the command-line arguments and returns the arguments to pass to the selected command. get_converter(hint) \u00b6 Returns a type converter keyed to a specific typehint. get_help(doc) \u00b6 Return the first line of a documentation string. get_prefixed_args(args) \u00b6 Split parsed values into transport and service dictionaries. main() \u00b6 Processes command-line arguments and calls any selected command. print_status(status) \u00b6 Prints the server version and status data. start_client(trn, parser, args) \u00b6 Connect to the remote server and execute a command. start_server(trn, args, svc_args) \u00b6 Start an RPC server with the configured services. io_stat_mode() \u00b6 Return whether stdout is piped, redirected, or connected to a tty. main() \u00b6 Convenient entry-point. parse_alias(name) \u00b6 Split name into module and alias if : is present.","title":"API"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#snekrpc.interface.Server","text":"Bases: Interface","title":"Server"},{"location":"api/#snekrpc.interface.Server.add_service","text":"Register a service with the server. You can register a service but keep it hidden from users by prefixing the name with an underscore. Service base classes and helpers.","title":"add_service"},{"location":"api/#snekrpc.service.ServiceProxy","text":"Client-side helper that exposes remote commands as callables.","title":"ServiceProxy"},{"location":"api/#snekrpc.service.ServiceProxy.__dir__","text":"Add remote command names to dir() results.","title":"__dir__"},{"location":"api/#snekrpc.service.ServiceProxy.__getattr__","text":"Return a cached callable or lazily wrap the remote command.","title":"__getattr__"},{"location":"api/#snekrpc.service.ServiceProxy.__init__","text":"Cache remote service metadata and wrap remote commands. When command_metadata is True , metadata will be loaded from the remote metadata service. When False , no metadata will be loaded. Otherwise, a sequence of command metadata can be provided directly.","title":"__init__"},{"location":"api/#snekrpc.service.ServiceSpec","text":"Bases: Struct Description of a callable signature.","title":"ServiceSpec"},{"location":"api/#snekrpc.service.ServiceSpec.from_service","text":"Serialize a service definition for metadata responses.","title":"from_service"},{"location":"api/#snekrpc.service.StreamInitiator","text":"Generator shim that ensures the generator is started.","title":"StreamInitiator"},{"location":"api/#snekrpc.service.StreamInitiator.__init__","text":"Prime the generator while preserving the first item.","title":"__init__"},{"location":"api/#snekrpc.service.StreamInitiator.__iter__","text":"Yield the cached first item followed by the original stream.","title":"__iter__"},{"location":"api/#snekrpc.service.wrap_call","text":"Wrap a remote call in retry logic, handling stream outputs. Base transport abstractions.","title":"wrap_call"},{"location":"api/#snekrpc.transport.Connection","text":"Wrap an underlying socket-like object and handle message encoding.","title":"Connection"},{"location":"api/#snekrpc.transport.Connection.url","text":"Return a string representation of the connection endpoint.","title":"url"},{"location":"api/#snekrpc.transport.Connection.__enter__","text":"Allow context-manager usage.","title":"__enter__"},{"location":"api/#snekrpc.transport.Connection.__exit__","text":"Close the connection when leaving a with block.","title":"__exit__"},{"location":"api/#snekrpc.transport.Connection.__init__","text":"Bind the connection to an interface instance and address.","title":"__init__"},{"location":"api/#snekrpc.transport.Connection.close","text":"Close the underlying socket/resource.","title":"close"},{"location":"api/#snekrpc.transport.Connection.recv","text":"Receive raw bytes.","title":"recv"},{"location":"api/#snekrpc.transport.Connection.send","text":"Send raw bytes.","title":"send"},{"location":"api/#snekrpc.transport.Transport","text":"Bases: ABC Base transport class mirrored across clients and servers.","title":"Transport"},{"location":"api/#snekrpc.transport.Transport.url","text":"Return the configured transport URL.","title":"url"},{"location":"api/#snekrpc.transport.Transport.__init__","text":"Store the normalized URL for later use.","title":"__init__"},{"location":"api/#snekrpc.transport.Transport.connect","text":"Connect to a remote endpoint and return a Connection.","title":"connect"},{"location":"api/#snekrpc.transport.Transport.join","text":"Block until the server threads exit.","title":"join"},{"location":"api/#snekrpc.transport.Transport.serve","text":"Start serving RPC requests.","title":"serve"},{"location":"api/#snekrpc.transport.Transport.stop","text":"Stop serving and release resources.","title":"stop"},{"location":"api/#snekrpc.transport.create","text":"Create a Transport instance for url . Codec base classes and helpers.","title":"create"},{"location":"api/#snekrpc.codec.Codec","text":"Bases: ABC Base class for codecs that know how to encode/decode RPC payloads.","title":"Codec"},{"location":"api/#snekrpc.codec.Codec.decode","text":"Deserialize bytes into Python objects.","title":"decode"},{"location":"api/#snekrpc.codec.Codec.encode","text":"Serialize msg into bytes. Formatter plugin infrastructure.","title":"encode"},{"location":"api/#snekrpc.formatter.Formatter","text":"Base class for converting RPC responses to user output.","title":"Formatter"},{"location":"api/#snekrpc.formatter.Formatter.format","text":"Return the raw value by default; subclasses can override.","title":"format"},{"location":"api/#snekrpc.formatter.Formatter.print","text":"Print a formatted representation of res .","title":"print"},{"location":"api/#snekrpc.formatter.Formatter.process","text":"Automatically iterate through generators and print results. Command-line entry points for interacting with local and remote servers.","title":"process"},{"location":"api/#snekrpc.cli.Parser","text":"Builds CLI parsers for both client and server workflows.","title":"Parser"},{"location":"api/#snekrpc.cli.Parser.__init__","text":"Initialize the base parser and global argument definitions.","title":"__init__"},{"location":"api/#snekrpc.cli.Parser.add_command_args","text":"Translate command metadata into argparse arguments.","title":"add_command_args"},{"location":"api/#snekrpc.cli.Parser.add_global_args","text":"Adds an argument group to parser for global arguments.","title":"add_global_args"},{"location":"api/#snekrpc.cli.Parser.add_option_arg","text":"Add an individual option flag, handling bool/kwargs special cases.","title":"add_option_arg"},{"location":"api/#snekrpc.cli.Parser.add_service_args","text":"Expose cls.__init__ parameters under the given service alias.","title":"add_service_args"},{"location":"api/#snekrpc.cli.Parser.add_transport_args","text":"Expose transport constructor parameters with a unique prefix.","title":"add_transport_args"},{"location":"api/#snekrpc.cli.Parser.add_transport_exception","text":"Display an error group when a transport fails to import.","title":"add_transport_exception"},{"location":"api/#snekrpc.cli.Parser.get_argument_help","text":"Build an argparse help string that includes hints and defaults.","title":"get_argument_help"},{"location":"api/#snekrpc.cli.Parser.get_argument_hint","text":"Return a placeholder string usable as metavar text.","title":"get_argument_hint"},{"location":"api/#snekrpc.cli.Parser.get_command_args","text":"Processes the command-line arguments and returns the arguments to pass to the selected command.","title":"get_command_args"},{"location":"api/#snekrpc.cli.Parser.get_converter","text":"Returns a type converter keyed to a specific typehint.","title":"get_converter"},{"location":"api/#snekrpc.cli.Parser.get_help","text":"Return the first line of a documentation string.","title":"get_help"},{"location":"api/#snekrpc.cli.Parser.get_prefixed_args","text":"Split parsed values into transport and service dictionaries.","title":"get_prefixed_args"},{"location":"api/#snekrpc.cli.Parser.main","text":"Processes command-line arguments and calls any selected command.","title":"main"},{"location":"api/#snekrpc.cli.Parser.print_status","text":"Prints the server version and status data.","title":"print_status"},{"location":"api/#snekrpc.cli.Parser.start_client","text":"Connect to the remote server and execute a command.","title":"start_client"},{"location":"api/#snekrpc.cli.Parser.start_server","text":"Start an RPC server with the configured services.","title":"start_server"},{"location":"api/#snekrpc.cli.io_stat_mode","text":"Return whether stdout is piped, redirected, or connected to a tty.","title":"io_stat_mode"},{"location":"api/#snekrpc.cli.main","text":"Convenient entry-point.","title":"main"},{"location":"api/#snekrpc.cli.parse_alias","text":"Split name into module and alias if : is present.","title":"parse_alias"},{"location":"client/","text":"Client \u00b6 API \u00b6 A server is created by setting a URL to define the transport to use, as well as the host and port to connect to (default: tcp://127.0.0.1:12321 ). client = snekrpc . Client( 'tcp://127.0.0.1:12321' ) svc = client . service( 'echo' ) print (svc . echo( 'hello' )) By default, the client will initiate a handshake with the server in order to determine which codec to use. This can be skipped by setting the codec directly. The client will connect on the first attempt to interact with the server. In this case, that is the call to service() . service() returns a proxy object which can be used to call service methods directly. As a convenience, services are also accessible as attributes on the Client instance, however the service() method is required when service names conflict with Client method names. print (client . echo . echo( 'hello' )) Retry behavior: client = snekrpc . Client(retry_count = 3 , retry_interval = 0.5 ) CLI \u00b6 The snekrpc CLI can connect to any server with a supported transport and codec. $ snekrpc --url http://127.0.0.1:8000 --codec json echo echo hello # use default transport and codec $ snekrpc health ping --count 3 Arguments will be defined for every service command argument. Command-line help will also be fully populated. $ snekrpc health ping -h usage: snekrpc health ping [ -h ] [ -c <int> ] [ -i <float> ] Respond at regular intervals. options: -h, --help show this help message and exit -c, --count <int> ( default: 1 ) -i, --interval <float> ( default: 1 .0 ) Streaming \u00b6 When a command expects a stream, the CLI accepts a file path or - for stdin. $ snekrpc file upload ./local.bin remote.bin $ snekrpc file upload - remote.bin < ./local.bin","title":"Client"},{"location":"client/#client","text":"","title":"Client"},{"location":"client/#api","text":"A server is created by setting a URL to define the transport to use, as well as the host and port to connect to (default: tcp://127.0.0.1:12321 ). client = snekrpc . Client( 'tcp://127.0.0.1:12321' ) svc = client . service( 'echo' ) print (svc . echo( 'hello' )) By default, the client will initiate a handshake with the server in order to determine which codec to use. This can be skipped by setting the codec directly. The client will connect on the first attempt to interact with the server. In this case, that is the call to service() . service() returns a proxy object which can be used to call service methods directly. As a convenience, services are also accessible as attributes on the Client instance, however the service() method is required when service names conflict with Client method names. print (client . echo . echo( 'hello' )) Retry behavior: client = snekrpc . Client(retry_count = 3 , retry_interval = 0.5 )","title":"API"},{"location":"client/#cli","text":"The snekrpc CLI can connect to any server with a supported transport and codec. $ snekrpc --url http://127.0.0.1:8000 --codec json echo echo hello # use default transport and codec $ snekrpc health ping --count 3 Arguments will be defined for every service command argument. Command-line help will also be fully populated. $ snekrpc health ping -h usage: snekrpc health ping [ -h ] [ -c <int> ] [ -i <float> ] Respond at regular intervals. options: -h, --help show this help message and exit -c, --count <int> ( default: 1 ) -i, --interval <float> ( default: 1 .0 )","title":"CLI"},{"location":"client/#streaming","text":"When a command expects a stream, the CLI accepts a file path or - for stdin. $ snekrpc file upload ./local.bin remote.bin $ snekrpc file upload - remote.bin < ./local.bin","title":"Streaming"},{"location":"protocol/","text":"","title":"Protocol"},{"location":"server/","text":"Server \u00b6 API \u00b6 A snekrpc server hosts a number of services. A service is defined by subclassing Service and marking some methods with command() . The class argument name is optional, but recommended in order to register a definitive name with the snekrpc system. import snekrpc class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value A server is created by setting a URL to define the transport to use, as well as the interface and port to bind to (default: tcp://127.0.0.1:12321 ). A codec can also be set for encoding/decoding to/from bytes for transfer over the transport (default: msgpack ). Once a Server instance has been created, you can add services with the add_service() method, which will expose the service using the name set in the class definition. server = snekrpc . Server( 'tcp://0.0.0.0:12321' , codec = 'json' ) server . add_service(EchoService()) server . serve() Notes: The server registers a hidden _meta service automatically to provide metadata to clients. add_service() accepts an name argument if you want the service exposed under a different name. Server(remote_tracebacks=True) will include tracebacks in error responses. Command metadata \u00b6 The clients rely on command metadata to fill in front-end details. Use param() for parameter docs or to hide parameters from display in help output. class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value Streaming \u00b6 If a command returns a generator, the values yielde d will be streamed to clients. If the first argument (and only the first argument) passed into a command is a generator, values will stream in from the client. class StreamService (snekrpc . Service, name = 'stream' ): @snekrpc . command() def echo ( self , values: Iterable[ str ]) -> Iterable[ str ]: yield from values CLI \u00b6 A server can also be started directly with the snekrpc CLI using the -S,--server flag. Services are added using -s,--service . # bind with the default: tcp://127.0.0.1:12321 $ snekrpc --server --service health --service file $ snekrpc --server --url unix:///tmp/snekrpc.sock --service health Only Service classes which have been registered will be available. There are a few built-in services (use snekrpc --list services to see them). Others can be added by module path and optionally given a different name by appending :<name> : $ snekrpc --server --service echo_service.EchoService:echo You can also import a module directly, in which case the service can be referenced by it's registered name: $ snekrpc --server --import echo_service --service echo","title":"Server"},{"location":"server/#server","text":"","title":"Server"},{"location":"server/#api","text":"A snekrpc server hosts a number of services. A service is defined by subclassing Service and marking some methods with command() . The class argument name is optional, but recommended in order to register a definitive name with the snekrpc system. import snekrpc class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value A server is created by setting a URL to define the transport to use, as well as the interface and port to bind to (default: tcp://127.0.0.1:12321 ). A codec can also be set for encoding/decoding to/from bytes for transfer over the transport (default: msgpack ). Once a Server instance has been created, you can add services with the add_service() method, which will expose the service using the name set in the class definition. server = snekrpc . Server( 'tcp://0.0.0.0:12321' , codec = 'json' ) server . add_service(EchoService()) server . serve() Notes: The server registers a hidden _meta service automatically to provide metadata to clients. add_service() accepts an name argument if you want the service exposed under a different name. Server(remote_tracebacks=True) will include tracebacks in error responses.","title":"API"},{"location":"server/#command-metadata","text":"The clients rely on command metadata to fill in front-end details. Use param() for parameter docs or to hide parameters from display in help output. class EchoService (snekrpc . Service, name = 'echo' ): @snekrpc . command() def echo ( self , value: str ) -> str : return value","title":"Command metadata"},{"location":"server/#streaming","text":"If a command returns a generator, the values yielde d will be streamed to clients. If the first argument (and only the first argument) passed into a command is a generator, values will stream in from the client. class StreamService (snekrpc . Service, name = 'stream' ): @snekrpc . command() def echo ( self , values: Iterable[ str ]) -> Iterable[ str ]: yield from values","title":"Streaming"},{"location":"server/#cli","text":"A server can also be started directly with the snekrpc CLI using the -S,--server flag. Services are added using -s,--service . # bind with the default: tcp://127.0.0.1:12321 $ snekrpc --server --service health --service file $ snekrpc --server --url unix:///tmp/snekrpc.sock --service health Only Service classes which have been registered will be available. There are a few built-in services (use snekrpc --list services to see them). Others can be added by module path and optionally given a different name by appending :<name> : $ snekrpc --server --service echo_service.EchoService:echo You can also import a module directly, in which case the service can be referenced by it's registered name: $ snekrpc --server --import echo_service --service echo","title":"CLI"},{"location":"services/","text":"Services \u00b6 Services group related RPC commands. A server holds a registry of service instances and exposes them by name. Commands are normal Python callables decorated with @snekrpc.command() . Defining a service \u00b6 import snekrpc class MathService (snekrpc . Service, name = 'math' ): @snekrpc . command() def add ( self , a: int , b: int ) -> int : return a + b server = snekrpc . Server() server . add_service(MathService()) server . serve() Built-in services \u00b6 Metadata ( meta / _meta ) \u00b6 The metadata service is automatically registered by the server under the alias _meta . It reports codec/transport information and provides command metadata used by the client and CLI. Commands include: status() service_names() services() service(name) Health ( health ) \u00b6 The health service provides a ping generator that yields regularly to keep a connection alive. File ( file ) \u00b6 The file service exposes basic filesystem operations including paths , upload , and download . By default, it uses safe_root=True to prevent path traversal beyond the configured root_path . Remote ( remote ) \u00b6 The remote service forwards calls to another endpoint by creating a nested client and exposing it under a new service name. Loading services from the CLI \u00b6 You can add services by name or by import path. $ snekrpc --server --service health --service file $ snekrpc --server --service mypkg.services.CustomService:alias","title":"Services"},{"location":"services/#services","text":"Services group related RPC commands. A server holds a registry of service instances and exposes them by name. Commands are normal Python callables decorated with @snekrpc.command() .","title":"Services"},{"location":"services/#defining-a-service","text":"import snekrpc class MathService (snekrpc . Service, name = 'math' ): @snekrpc . command() def add ( self , a: int , b: int ) -> int : return a + b server = snekrpc . Server() server . add_service(MathService()) server . serve()","title":"Defining a service"},{"location":"services/#built-in-services","text":"","title":"Built-in services"},{"location":"services/#metadata-meta-_meta","text":"The metadata service is automatically registered by the server under the alias _meta . It reports codec/transport information and provides command metadata used by the client and CLI. Commands include: status() service_names() services() service(name)","title":"Metadata (meta / _meta)"},{"location":"services/#health-health","text":"The health service provides a ping generator that yields regularly to keep a connection alive.","title":"Health (health)"},{"location":"services/#file-file","text":"The file service exposes basic filesystem operations including paths , upload , and download . By default, it uses safe_root=True to prevent path traversal beyond the configured root_path .","title":"File (file)"},{"location":"services/#remote-remote","text":"The remote service forwards calls to another endpoint by creating a nested client and exposing it under a new service name.","title":"Remote (remote)"},{"location":"services/#loading-services-from-the-cli","text":"You can add services by name or by import path. $ snekrpc --server --service health --service file $ snekrpc --server --service mypkg.services.CustomService:alias","title":"Loading services from the CLI"}]}